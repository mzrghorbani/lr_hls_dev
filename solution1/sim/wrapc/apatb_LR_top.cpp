// ==============================================================
// Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2019.1 (64-bit)
// Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
// ==============================================================

#include <systemc>
#include <iostream>
#include <cstdlib>
#include <cstddef>
#include <stdint.h>
#include "SysCFileHandler.h"
#include "ap_int.h"
#include "ap_fixed.h"
#include <complex>
#include <stdbool.h>
#include "autopilot_cbe.h"
#include "hls_stream.h"
#include "hls_half.h"
#include "hls_signal_handler.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


// [dump_struct_tree [build_nameSpaceTree] dumpedStructList] ---------->
    namespace TMTT
    {
        typedef struct SettingsHLS {
            unsigned int lrNumIterations_;
            unsigned int lrMinLayers_;
            unsigned int lrMinLayersPS_;
            float lrResidPhi_;
            float lrResidZ2S_;
            float lrResidZPS_;
            float chosenRofPhi_;
            float chosenRofZ_;
            float invPtToDphi_;
            int trackerNumLayers_;
           } SettingsHLS;

           typedef struct ModuleHLS {
               TMTT::SettingsHLS settingsHLS_;
               bool barrel_;
               bool psModule_;
               unsigned int layerId_;
              } ModuleHLS;

              typedef struct StubHLS {
                  TMTT::SettingsHLS settingsHLS_;
                  TMTT::ModuleHLS moduleHLS_;
                  float r_;
                  float phi_;
                  float z_;
                 } StubHLS;

                 template< typename T > struct arrayHLS;
                 template<> struct arrayHLS<TMTT::StubHLS> {
                     unsigned int size_;
                     TMTT::StubHLS data_[16];
                    } ;

                    typedef struct TrackHLS {
                        TMTT::SettingsHLS settingsHLS_;
                        TMTT::arrayHLS<TMTT::StubHLS > stubsHLS_;
                        unsigned int secEta_;
                        unsigned int secPhi_;
                        float qOverPt_;
                        float phi_;
                        float z_;
                        float cot_;
                       } TrackHLS;

                       template< typename T > struct arrayHLS;
                       template<> struct arrayHLS<TMTT::TrackHLS> {
                           unsigned int size_;
                           TMTT::TrackHLS data_[16];
                          } ;

                          typedef struct DataHLS {
                              TMTT::SettingsHLS settingsHLS_;
                              TMTT::arrayHLS<TMTT::TrackHLS > tracksMHTHLS_;
                              TMTT::arrayHLS<TMTT::TrackHLS > tracksLRHLS_;
                             } DataHLS;

                             typedef struct LRTrack {
                                 float qOverPt;
                                 float phiT;
                                 float cotTheta;
                                 float zT;
                                } LRTrack;

                                template< typename T1 ,typename T2 > struct pairHLS;
                                template<> struct pairHLS<unsigned int, TMTT::arrayHLS<TMTT::StubHLS> > {
                                    unsigned int first;
                                    TMTT::arrayHLS<TMTT::StubHLS > second;
                                   } ;

                                   template< typename key ,typename T > struct mapHLS;
                                   template<> struct mapHLS<unsigned int, TMTT::arrayHLS<TMTT::StubHLS> > {
                                       unsigned int size_;
                                       TMTT::pairHLS<unsigned int, TMTT::arrayHLS<TMTT::StubHLS > > data_[30];
                                      } ;

                                      template< typename T1 ,typename T2 > struct pairHLS;
                                      template<> struct pairHLS<unsigned int, unsigned int> {
                                          unsigned int first;
                                          unsigned int second;
                                         } ;

                                         template< typename key ,typename T > struct mapHLS;
                                         template<> struct mapHLS<unsigned int, unsigned int> {
                                             unsigned int size_;
                                             TMTT::pairHLS<unsigned int, unsigned int > data_[30];
                                            } ;

                                            typedef struct Residual {
                                                float phi;
                                                float z;
                                                unsigned int layerId;
                                                unsigned int stubId;
                                                bool ps;
                                               } Residual;

                                               template< typename T > struct arrayHLS;
                                               template<> struct arrayHLS<TMTT::Residual> {
                                                   unsigned int size_;
                                                   TMTT::Residual data_[16];
                                                  } ;

                                                  template< typename T1 ,typename T2 > struct pairHLS;
                                                  template<> struct pairHLS<unsigned int, TMTT::arrayHLS<TMTT::Residual> > {
                                                      unsigned int first;
                                                      TMTT::arrayHLS<TMTT::Residual > second;
                                                     } ;

                                                     template< typename key ,typename T > struct mapHLS;
                                                     template<> struct mapHLS<unsigned int, TMTT::arrayHLS<TMTT::Residual> > {
                                                         unsigned int size_;
                                                         TMTT::pairHLS<unsigned int, TMTT::arrayHLS<TMTT::Residual > > data_[30];
                                                        } ;

                                                        typedef struct LRHLS {
                                                            TMTT::SettingsHLS settings_;
                                                            TMTT::DataHLS data_;
                                                            const unsigned int numLayers_;
                                                            const unsigned int minLayers_;
                                                            const unsigned int minLayersPS_;
                                                            const float residPhi_;
                                                            const float residZ2S_;
                                                            const float residZPS_;
                                                            const int maxIteartions_;
                                                            TMTT::TrackHLS track_;
                                                            unsigned int secPhi_;
                                                            unsigned int secEta_;
                                                            TMTT::LRTrack HTParameter_;
                                                            TMTT::LRTrack LRParameter_;
                                                            TMTT::arrayHLS<TMTT::StubHLS > stubs_;
                                                            bool valid_;
                                                            TMTT::mapHLS<unsigned int, TMTT::arrayHLS<TMTT::StubHLS > > stubMap_;
                                                            TMTT::mapHLS<unsigned int, unsigned int > layerPopulation_;
                                                            TMTT::mapHLS<unsigned int, TMTT::arrayHLS<TMTT::Residual > > residuals_;
                                                            TMTT::Residual largestResid_;
                                                            unsigned int nIterations_;
                                                           } LRHLS;

                                                          };



// [dump_enumeration [get_enumeration_list]] ---------->


// wrapc file define: "lrhls_settings_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_settings_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_settings_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_settings_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_settings_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_settings_chosenRofZ_s.dat"
// wrapc file define: "lrhls_settings_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_settings_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_settings_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_size_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_size_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_size_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_secEta_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secEta_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_secEta_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_secPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_secPhi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_qOverPt_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_qOverPt_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_qOverPt_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_phi_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_phi_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_z_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_z_s.dat"
// wrapc file define: "lrhls_data_tracksMHTHLS_data_cot_s"
#define AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_cot_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksMHTHLS_data_cot_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_size_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_size_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_size_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_secEta_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secEta_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_secEta_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_secPhi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_secPhi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_qOverPt_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_qOverPt_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_qOverPt_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_phi_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_phi_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_z_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_z_s.dat"
// wrapc file define: "lrhls_data_tracksLRHLS_data_cot_s"
#define AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_cot_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_data_tracksLRHLS_data_cot_s.dat"
// wrapc file define: "lrhls_numLayers_s"
#define AUTOTB_TVIN_lrhls_numLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_numLayers_s.dat"
// wrapc file define: "lrhls_minLayers_s"
#define AUTOTB_TVIN_lrhls_minLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_minLayers_s.dat"
// wrapc file define: "lrhls_minLayersPS_s"
#define AUTOTB_TVIN_lrhls_minLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_minLayersPS_s.dat"
// wrapc file define: "lrhls_residPhi_s"
#define AUTOTB_TVIN_lrhls_residPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residPhi_s.dat"
// wrapc file define: "lrhls_residZ2S_s"
#define AUTOTB_TVIN_lrhls_residZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residZ2S_s.dat"
// wrapc file define: "lrhls_residZPS_s"
#define AUTOTB_TVIN_lrhls_residZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residZPS_s.dat"
// wrapc file define: "lrhls_maxIteartions_s"
#define AUTOTB_TVIN_lrhls_maxIteartions_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_maxIteartions_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_track_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_track_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_size_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_size_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_size_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_barrel_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_psModule_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_moduleHLS_layerId_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_r_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_r_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_r_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_r_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_r_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_phi_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_phi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_phi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_phi_s.dat"
// wrapc file define: "lrhls_track_stubsHLS_data_z_s"
#define AUTOTB_TVIN_lrhls_track_stubsHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_stubsHLS_data_z_s.dat"
#define AUTOTB_TVOUT_lrhls_track_stubsHLS_data_z_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_stubsHLS_data_z_s.dat"
// wrapc file define: "lrhls_track_secEta_s"
#define AUTOTB_TVIN_lrhls_track_secEta_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_secEta_s.dat"
#define AUTOTB_TVOUT_lrhls_track_secEta_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_secEta_s.dat"
// wrapc file define: "lrhls_track_secPhi_s"
#define AUTOTB_TVIN_lrhls_track_secPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_secPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_secPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_secPhi_s.dat"
// wrapc file define: "lrhls_track_qOverPt_s"
#define AUTOTB_TVIN_lrhls_track_qOverPt_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_qOverPt_s.dat"
#define AUTOTB_TVOUT_lrhls_track_qOverPt_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_qOverPt_s.dat"
// wrapc file define: "lrhls_track_phi_s"
#define AUTOTB_TVIN_lrhls_track_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_phi_s.dat"
#define AUTOTB_TVOUT_lrhls_track_phi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_phi_s.dat"
// wrapc file define: "lrhls_track_z_s"
#define AUTOTB_TVIN_lrhls_track_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_z_s.dat"
#define AUTOTB_TVOUT_lrhls_track_z_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_z_s.dat"
// wrapc file define: "lrhls_track_cot_s"
#define AUTOTB_TVIN_lrhls_track_cot_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_track_cot_s.dat"
#define AUTOTB_TVOUT_lrhls_track_cot_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_track_cot_s.dat"
// wrapc file define: "lrhls_secPhi_s"
#define AUTOTB_TVOUT_lrhls_secPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_secPhi_s.dat"
// wrapc file define: "lrhls_secEta_s"
#define AUTOTB_TVOUT_lrhls_secEta_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_secEta_s.dat"
// wrapc file define: "lrhls_HTParameter_qOverPt"
#define AUTOTB_TVIN_lrhls_HTParameter_qOverPt  "../tv/cdatafile/c.LR_top.autotvin_lrhls_HTParameter_qOverPt.dat"
#define AUTOTB_TVOUT_lrhls_HTParameter_qOverPt  "../tv/cdatafile/c.LR_top.autotvout_lrhls_HTParameter_qOverPt.dat"
// wrapc file define: "lrhls_HTParameter_phiT"
#define AUTOTB_TVIN_lrhls_HTParameter_phiT  "../tv/cdatafile/c.LR_top.autotvin_lrhls_HTParameter_phiT.dat"
#define AUTOTB_TVOUT_lrhls_HTParameter_phiT  "../tv/cdatafile/c.LR_top.autotvout_lrhls_HTParameter_phiT.dat"
// wrapc file define: "lrhls_HTParameter_cotTheta"
#define AUTOTB_TVIN_lrhls_HTParameter_cotTheta  "../tv/cdatafile/c.LR_top.autotvin_lrhls_HTParameter_cotTheta.dat"
#define AUTOTB_TVOUT_lrhls_HTParameter_cotTheta  "../tv/cdatafile/c.LR_top.autotvout_lrhls_HTParameter_cotTheta.dat"
// wrapc file define: "lrhls_HTParameter_zT"
#define AUTOTB_TVIN_lrhls_HTParameter_zT  "../tv/cdatafile/c.LR_top.autotvin_lrhls_HTParameter_zT.dat"
#define AUTOTB_TVOUT_lrhls_HTParameter_zT  "../tv/cdatafile/c.LR_top.autotvout_lrhls_HTParameter_zT.dat"
// wrapc file define: "lrhls_LRParameter_qOverPt"
#define AUTOTB_TVIN_lrhls_LRParameter_qOverPt  "../tv/cdatafile/c.LR_top.autotvin_lrhls_LRParameter_qOverPt.dat"
#define AUTOTB_TVOUT_lrhls_LRParameter_qOverPt  "../tv/cdatafile/c.LR_top.autotvout_lrhls_LRParameter_qOverPt.dat"
// wrapc file define: "lrhls_LRParameter_phiT"
#define AUTOTB_TVIN_lrhls_LRParameter_phiT  "../tv/cdatafile/c.LR_top.autotvin_lrhls_LRParameter_phiT.dat"
#define AUTOTB_TVOUT_lrhls_LRParameter_phiT  "../tv/cdatafile/c.LR_top.autotvout_lrhls_LRParameter_phiT.dat"
// wrapc file define: "lrhls_LRParameter_cotTheta"
#define AUTOTB_TVIN_lrhls_LRParameter_cotTheta  "../tv/cdatafile/c.LR_top.autotvin_lrhls_LRParameter_cotTheta.dat"
#define AUTOTB_TVOUT_lrhls_LRParameter_cotTheta  "../tv/cdatafile/c.LR_top.autotvout_lrhls_LRParameter_cotTheta.dat"
// wrapc file define: "lrhls_LRParameter_zT"
#define AUTOTB_TVIN_lrhls_LRParameter_zT  "../tv/cdatafile/c.LR_top.autotvin_lrhls_LRParameter_zT.dat"
#define AUTOTB_TVOUT_lrhls_LRParameter_zT  "../tv/cdatafile/c.LR_top.autotvout_lrhls_LRParameter_zT.dat"
// wrapc file define: "lrhls_stubs_size_s"
#define AUTOTB_TVIN_lrhls_stubs_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_size_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_size_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_stubs_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_barrel_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_barrel_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_barrel_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_psModule_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_psModule_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_psModule_s.dat"
// wrapc file define: "lrhls_stubs_data_moduleHLS_layerId_s"
#define AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_moduleHLS_layerId_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_moduleHLS_layerId_s.dat"
// wrapc file define: "lrhls_stubs_data_r_s"
#define AUTOTB_TVIN_lrhls_stubs_data_r_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_r_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_r_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_r_s.dat"
// wrapc file define: "lrhls_stubs_data_phi_s"
#define AUTOTB_TVIN_lrhls_stubs_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_phi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_phi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_phi_s.dat"
// wrapc file define: "lrhls_stubs_data_z_s"
#define AUTOTB_TVIN_lrhls_stubs_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubs_data_z_s.dat"
#define AUTOTB_TVOUT_lrhls_stubs_data_z_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubs_data_z_s.dat"
// wrapc file define: "lrhls_valid_s"
#define AUTOTB_TVIN_lrhls_valid_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_valid_s.dat"
#define AUTOTB_TVOUT_lrhls_valid_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_valid_s.dat"
// wrapc file define: "lrhls_stubMap_size_s"
#define AUTOTB_TVIN_lrhls_stubMap_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_size_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_size_s.dat"
// wrapc file define: "lrhls_stubMap_data_first"
#define AUTOTB_TVIN_lrhls_stubMap_data_first  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_first.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_first  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_first.dat"
// wrapc file define: "lrhls_stubMap_data_second_size_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_size_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_size_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_barrel_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_barrel_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_psModule_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_psModule_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_moduleHLS_layerId_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_layerId_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_r_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_r_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_r_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_r_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_r_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_phi_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_phi_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_phi_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_phi_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_phi_s.dat"
// wrapc file define: "lrhls_stubMap_data_second_data_z_s"
#define AUTOTB_TVIN_lrhls_stubMap_data_second_data_z_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_stubMap_data_second_data_z_s.dat"
#define AUTOTB_TVOUT_lrhls_stubMap_data_second_data_z_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_stubMap_data_second_data_z_s.dat"
// wrapc file define: "lrhls_layerPopulation_size_s"
#define AUTOTB_TVIN_lrhls_layerPopulation_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_layerPopulation_size_s.dat"
#define AUTOTB_TVOUT_lrhls_layerPopulation_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_layerPopulation_size_s.dat"
// wrapc file define: "lrhls_layerPopulation_data_first"
#define AUTOTB_TVIN_lrhls_layerPopulation_data_first  "../tv/cdatafile/c.LR_top.autotvin_lrhls_layerPopulation_data_first.dat"
#define AUTOTB_TVOUT_lrhls_layerPopulation_data_first  "../tv/cdatafile/c.LR_top.autotvout_lrhls_layerPopulation_data_first.dat"
// wrapc file define: "lrhls_layerPopulation_data_second"
#define AUTOTB_TVIN_lrhls_layerPopulation_data_second  "../tv/cdatafile/c.LR_top.autotvin_lrhls_layerPopulation_data_second.dat"
#define AUTOTB_TVOUT_lrhls_layerPopulation_data_second  "../tv/cdatafile/c.LR_top.autotvout_lrhls_layerPopulation_data_second.dat"
// wrapc file define: "lrhls_residuals_size_s"
#define AUTOTB_TVOUT_lrhls_residuals_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_size_s.dat"
// wrapc file define: "lrhls_residuals_data_first"
#define AUTOTB_TVIN_lrhls_residuals_data_first  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_first.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_first  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_first.dat"
// wrapc file define: "lrhls_residuals_data_second_size_s"
#define AUTOTB_TVIN_lrhls_residuals_data_second_size_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_size_s.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_size_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_size_s.dat"
// wrapc file define: "lrhls_residuals_data_second_data_phi"
#define AUTOTB_TVIN_lrhls_residuals_data_second_data_phi  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_data_phi.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_data_phi  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_data_phi.dat"
// wrapc file define: "lrhls_residuals_data_second_data_z"
#define AUTOTB_TVIN_lrhls_residuals_data_second_data_z  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_data_z.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_data_z  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_data_z.dat"
// wrapc file define: "lrhls_residuals_data_second_data_layerId"
#define AUTOTB_TVIN_lrhls_residuals_data_second_data_layerId  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_data_layerId.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_data_layerId  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_data_layerId.dat"
// wrapc file define: "lrhls_residuals_data_second_data_stubId"
#define AUTOTB_TVIN_lrhls_residuals_data_second_data_stubId  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_data_stubId.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_data_stubId  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_data_stubId.dat"
// wrapc file define: "lrhls_residuals_data_second_data_ps"
#define AUTOTB_TVIN_lrhls_residuals_data_second_data_ps  "../tv/cdatafile/c.LR_top.autotvin_lrhls_residuals_data_second_data_ps.dat"
#define AUTOTB_TVOUT_lrhls_residuals_data_second_data_ps  "../tv/cdatafile/c.LR_top.autotvout_lrhls_residuals_data_second_data_ps.dat"
// wrapc file define: "lrhls_largestResid_phi"
#define AUTOTB_TVOUT_lrhls_largestResid_phi  "../tv/cdatafile/c.LR_top.autotvout_lrhls_largestResid_phi.dat"
// wrapc file define: "lrhls_largestResid_z"
#define AUTOTB_TVOUT_lrhls_largestResid_z  "../tv/cdatafile/c.LR_top.autotvout_lrhls_largestResid_z.dat"
// wrapc file define: "lrhls_largestResid_layerId"
#define AUTOTB_TVOUT_lrhls_largestResid_layerId  "../tv/cdatafile/c.LR_top.autotvout_lrhls_largestResid_layerId.dat"
// wrapc file define: "lrhls_largestResid_stubId"
#define AUTOTB_TVOUT_lrhls_largestResid_stubId  "../tv/cdatafile/c.LR_top.autotvout_lrhls_largestResid_stubId.dat"
// wrapc file define: "lrhls_largestResid_ps"
#define AUTOTB_TVOUT_lrhls_largestResid_ps  "../tv/cdatafile/c.LR_top.autotvout_lrhls_largestResid_ps.dat"
// wrapc file define: "lrhls_nIterations_s"
#define AUTOTB_TVIN_lrhls_nIterations_s  "../tv/cdatafile/c.LR_top.autotvin_lrhls_nIterations_s.dat"
#define AUTOTB_TVOUT_lrhls_nIterations_s  "../tv/cdatafile/c.LR_top.autotvout_lrhls_nIterations_s.dat"

#define INTER_TCL  "../tv/cdatafile/ref.tcl"

// tvout file define: "lrhls_track_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_track_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_track_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_track_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_track_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_track_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_track_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_track_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_track_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_track_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_track_stubsHLS_size_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_size_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_barrel_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_psModule_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_moduleHLS_layerId_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_r_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_r_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_phi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_phi_s.dat"
// tvout file define: "lrhls_track_stubsHLS_data_z_s"
#define AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_stubsHLS_data_z_s.dat"
// tvout file define: "lrhls_track_secEta_s"
#define AUTOTB_TVOUT_PC_lrhls_track_secEta_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_secEta_s.dat"
// tvout file define: "lrhls_track_secPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_secPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_secPhi_s.dat"
// tvout file define: "lrhls_track_qOverPt_s"
#define AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_qOverPt_s.dat"
// tvout file define: "lrhls_track_phi_s"
#define AUTOTB_TVOUT_PC_lrhls_track_phi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_phi_s.dat"
// tvout file define: "lrhls_track_z_s"
#define AUTOTB_TVOUT_PC_lrhls_track_z_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_z_s.dat"
// tvout file define: "lrhls_track_cot_s"
#define AUTOTB_TVOUT_PC_lrhls_track_cot_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_track_cot_s.dat"
// tvout file define: "lrhls_secPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_secPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_secPhi_s.dat"
// tvout file define: "lrhls_secEta_s"
#define AUTOTB_TVOUT_PC_lrhls_secEta_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_secEta_s.dat"
// tvout file define: "lrhls_HTParameter_qOverPt"
#define AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_HTParameter_qOverPt.dat"
// tvout file define: "lrhls_HTParameter_phiT"
#define AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_HTParameter_phiT.dat"
// tvout file define: "lrhls_HTParameter_cotTheta"
#define AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_HTParameter_cotTheta.dat"
// tvout file define: "lrhls_HTParameter_zT"
#define AUTOTB_TVOUT_PC_lrhls_HTParameter_zT  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_HTParameter_zT.dat"
// tvout file define: "lrhls_LRParameter_qOverPt"
#define AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_LRParameter_qOverPt.dat"
// tvout file define: "lrhls_LRParameter_phiT"
#define AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_LRParameter_phiT.dat"
// tvout file define: "lrhls_LRParameter_cotTheta"
#define AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_LRParameter_cotTheta.dat"
// tvout file define: "lrhls_LRParameter_zT"
#define AUTOTB_TVOUT_PC_lrhls_LRParameter_zT  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_LRParameter_zT.dat"
// tvout file define: "lrhls_stubs_size_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_size_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_stubs_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_barrel_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_barrel_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_psModule_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_psModule_s.dat"
// tvout file define: "lrhls_stubs_data_moduleHLS_layerId_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_moduleHLS_layerId_s.dat"
// tvout file define: "lrhls_stubs_data_r_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_r_s.dat"
// tvout file define: "lrhls_stubs_data_phi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_phi_s.dat"
// tvout file define: "lrhls_stubs_data_z_s"
#define AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubs_data_z_s.dat"
// tvout file define: "lrhls_valid_s"
#define AUTOTB_TVOUT_PC_lrhls_valid_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_valid_s.dat"
// tvout file define: "lrhls_stubMap_size_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_size_s.dat"
// tvout file define: "lrhls_stubMap_data_first"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_first  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_first.dat"
// tvout file define: "lrhls_stubMap_data_second_size_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_size_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_barrel_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_psModule_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_moduleHLS_layerId_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_r_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_r_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_phi_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_phi_s.dat"
// tvout file define: "lrhls_stubMap_data_second_data_z_s"
#define AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_stubMap_data_second_data_z_s.dat"
// tvout file define: "lrhls_layerPopulation_size_s"
#define AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_layerPopulation_size_s.dat"
// tvout file define: "lrhls_layerPopulation_data_first"
#define AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_layerPopulation_data_first.dat"
// tvout file define: "lrhls_layerPopulation_data_second"
#define AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_layerPopulation_data_second.dat"
// tvout file define: "lrhls_residuals_size_s"
#define AUTOTB_TVOUT_PC_lrhls_residuals_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_size_s.dat"
// tvout file define: "lrhls_residuals_data_first"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_first  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_first.dat"
// tvout file define: "lrhls_residuals_data_second_size_s"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_size_s.dat"
// tvout file define: "lrhls_residuals_data_second_data_phi"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_data_phi.dat"
// tvout file define: "lrhls_residuals_data_second_data_z"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_data_z.dat"
// tvout file define: "lrhls_residuals_data_second_data_layerId"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_data_layerId.dat"
// tvout file define: "lrhls_residuals_data_second_data_stubId"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_data_stubId.dat"
// tvout file define: "lrhls_residuals_data_second_data_ps"
#define AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_residuals_data_second_data_ps.dat"
// tvout file define: "lrhls_largestResid_phi"
#define AUTOTB_TVOUT_PC_lrhls_largestResid_phi  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_largestResid_phi.dat"
// tvout file define: "lrhls_largestResid_z"
#define AUTOTB_TVOUT_PC_lrhls_largestResid_z  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_largestResid_z.dat"
// tvout file define: "lrhls_largestResid_layerId"
#define AUTOTB_TVOUT_PC_lrhls_largestResid_layerId  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_largestResid_layerId.dat"
// tvout file define: "lrhls_largestResid_stubId"
#define AUTOTB_TVOUT_PC_lrhls_largestResid_stubId  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_largestResid_stubId.dat"
// tvout file define: "lrhls_largestResid_ps"
#define AUTOTB_TVOUT_PC_lrhls_largestResid_ps  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_largestResid_ps.dat"
// tvout file define: "lrhls_nIterations_s"
#define AUTOTB_TVOUT_PC_lrhls_nIterations_s  "../tv/rtldatafile/rtl.LR_top.autotvout_lrhls_nIterations_s.dat"

class INTER_TCL_FILE {
	public:
		INTER_TCL_FILE(const char* name) {
			mName = name;
			lrhls_settings_chosenRofPhi_s_depth = 0;
			lrhls_settings_chosenRofZ_s_depth = 0;
			lrhls_settings_invPtToDphi_s_depth = 0;
			lrhls_data_tracksMHTHLS_size_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_secEta_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_secPhi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_qOverPt_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_phi_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_z_s_depth = 0;
			lrhls_data_tracksMHTHLS_data_cot_s_depth = 0;
			lrhls_data_tracksLRHLS_size_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_size_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_depth = 0;
			lrhls_data_tracksLRHLS_data_secEta_s_depth = 0;
			lrhls_data_tracksLRHLS_data_secPhi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_qOverPt_s_depth = 0;
			lrhls_data_tracksLRHLS_data_phi_s_depth = 0;
			lrhls_data_tracksLRHLS_data_z_s_depth = 0;
			lrhls_data_tracksLRHLS_data_cot_s_depth = 0;
			lrhls_numLayers_s_depth = 0;
			lrhls_minLayers_s_depth = 0;
			lrhls_minLayersPS_s_depth = 0;
			lrhls_residPhi_s_depth = 0;
			lrhls_residZ2S_s_depth = 0;
			lrhls_residZPS_s_depth = 0;
			lrhls_maxIteartions_s_depth = 0;
			lrhls_track_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_track_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_track_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_track_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_track_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_track_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_track_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_track_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_track_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_track_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_track_stubsHLS_size_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_barrel_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_psModule_s_depth = 0;
			lrhls_track_stubsHLS_data_moduleHLS_layerId_s_depth = 0;
			lrhls_track_stubsHLS_data_r_s_depth = 0;
			lrhls_track_stubsHLS_data_phi_s_depth = 0;
			lrhls_track_stubsHLS_data_z_s_depth = 0;
			lrhls_track_secEta_s_depth = 0;
			lrhls_track_secPhi_s_depth = 0;
			lrhls_track_qOverPt_s_depth = 0;
			lrhls_track_phi_s_depth = 0;
			lrhls_track_z_s_depth = 0;
			lrhls_track_cot_s_depth = 0;
			lrhls_secPhi_s_depth = 0;
			lrhls_secEta_s_depth = 0;
			lrhls_HTParameter_qOverPt_depth = 0;
			lrhls_HTParameter_phiT_depth = 0;
			lrhls_HTParameter_cotTheta_depth = 0;
			lrhls_HTParameter_zT_depth = 0;
			lrhls_LRParameter_qOverPt_depth = 0;
			lrhls_LRParameter_phiT_depth = 0;
			lrhls_LRParameter_cotTheta_depth = 0;
			lrhls_LRParameter_zT_depth = 0;
			lrhls_stubs_size_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_stubs_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_stubs_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_stubs_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_stubs_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_stubs_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_stubs_data_moduleHLS_barrel_s_depth = 0;
			lrhls_stubs_data_moduleHLS_psModule_s_depth = 0;
			lrhls_stubs_data_moduleHLS_layerId_s_depth = 0;
			lrhls_stubs_data_r_s_depth = 0;
			lrhls_stubs_data_phi_s_depth = 0;
			lrhls_stubs_data_z_s_depth = 0;
			lrhls_valid_s_depth = 0;
			lrhls_stubMap_size_s_depth = 0;
			lrhls_stubMap_data_first_depth = 0;
			lrhls_stubMap_data_second_size_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_barrel_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_psModule_s_depth = 0;
			lrhls_stubMap_data_second_data_moduleHLS_layerId_s_depth = 0;
			lrhls_stubMap_data_second_data_r_s_depth = 0;
			lrhls_stubMap_data_second_data_phi_s_depth = 0;
			lrhls_stubMap_data_second_data_z_s_depth = 0;
			lrhls_layerPopulation_size_s_depth = 0;
			lrhls_layerPopulation_data_first_depth = 0;
			lrhls_layerPopulation_data_second_depth = 0;
			lrhls_residuals_size_s_depth = 0;
			lrhls_residuals_data_first_depth = 0;
			lrhls_residuals_data_second_size_s_depth = 0;
			lrhls_residuals_data_second_data_phi_depth = 0;
			lrhls_residuals_data_second_data_z_depth = 0;
			lrhls_residuals_data_second_data_layerId_depth = 0;
			lrhls_residuals_data_second_data_stubId_depth = 0;
			lrhls_residuals_data_second_data_ps_depth = 0;
			lrhls_largestResid_phi_depth = 0;
			lrhls_largestResid_z_depth = 0;
			lrhls_largestResid_layerId_depth = 0;
			lrhls_largestResid_stubId_depth = 0;
			lrhls_largestResid_ps_depth = 0;
			lrhls_nIterations_s_depth = 0;
			trans_num =0;
		}

		~INTER_TCL_FILE() {
			mFile.open(mName);
			if (!mFile.good()) {
				cout << "Failed to open file ref.tcl" << endl;
				exit (1);
			}
			string total_list = get_depth_list();
			mFile << "set depth_list {\n";
			mFile << total_list;
			mFile << "}\n";
			mFile << "set trans_num "<<trans_num<<endl;
			mFile.close();
		}

		string get_depth_list () {
			stringstream total_list;
			total_list << "{lrhls_settings_chosenRofPhi_s " << lrhls_settings_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_settings_chosenRofZ_s " << lrhls_settings_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_settings_invPtToDphi_s " << lrhls_settings_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_size_s " << lrhls_data_tracksMHTHLS_size_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_size_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s " << lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_secEta_s " << lrhls_data_tracksMHTHLS_data_secEta_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_secPhi_s " << lrhls_data_tracksMHTHLS_data_secPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_qOverPt_s " << lrhls_data_tracksMHTHLS_data_qOverPt_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_phi_s " << lrhls_data_tracksMHTHLS_data_phi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_z_s " << lrhls_data_tracksMHTHLS_data_z_s_depth << "}\n";
			total_list << "{lrhls_data_tracksMHTHLS_data_cot_s " << lrhls_data_tracksMHTHLS_data_cot_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_size_s " << lrhls_data_tracksLRHLS_size_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s " << lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s " << lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s " << lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_size_s " << lrhls_data_tracksLRHLS_data_stubsHLS_size_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s " << lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_secEta_s " << lrhls_data_tracksLRHLS_data_secEta_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_secPhi_s " << lrhls_data_tracksLRHLS_data_secPhi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_qOverPt_s " << lrhls_data_tracksLRHLS_data_qOverPt_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_phi_s " << lrhls_data_tracksLRHLS_data_phi_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_z_s " << lrhls_data_tracksLRHLS_data_z_s_depth << "}\n";
			total_list << "{lrhls_data_tracksLRHLS_data_cot_s " << lrhls_data_tracksLRHLS_data_cot_s_depth << "}\n";
			total_list << "{lrhls_numLayers_s " << lrhls_numLayers_s_depth << "}\n";
			total_list << "{lrhls_minLayers_s " << lrhls_minLayers_s_depth << "}\n";
			total_list << "{lrhls_minLayersPS_s " << lrhls_minLayersPS_s_depth << "}\n";
			total_list << "{lrhls_residPhi_s " << lrhls_residPhi_s_depth << "}\n";
			total_list << "{lrhls_residZ2S_s " << lrhls_residZ2S_s_depth << "}\n";
			total_list << "{lrhls_residZPS_s " << lrhls_residZPS_s_depth << "}\n";
			total_list << "{lrhls_maxIteartions_s " << lrhls_maxIteartions_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrNumIterations_s " << lrhls_track_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrMinLayers_s " << lrhls_track_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrMinLayersPS_s " << lrhls_track_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrResidPhi_s " << lrhls_track_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrResidZ2S_s " << lrhls_track_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_lrResidZPS_s " << lrhls_track_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_chosenRofPhi_s " << lrhls_track_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_chosenRofZ_s " << lrhls_track_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_invPtToDphi_s " << lrhls_track_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_track_settingsHLS_trackerNumLayers_s " << lrhls_track_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_size_s " << lrhls_track_stubsHLS_size_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s " << lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s " << lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s " << lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s " << lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s " << lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s " << lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s " << lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s " << lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s " << lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s " << lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s " << lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_barrel_s " << lrhls_track_stubsHLS_data_moduleHLS_barrel_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_psModule_s " << lrhls_track_stubsHLS_data_moduleHLS_psModule_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_moduleHLS_layerId_s " << lrhls_track_stubsHLS_data_moduleHLS_layerId_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_r_s " << lrhls_track_stubsHLS_data_r_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_phi_s " << lrhls_track_stubsHLS_data_phi_s_depth << "}\n";
			total_list << "{lrhls_track_stubsHLS_data_z_s " << lrhls_track_stubsHLS_data_z_s_depth << "}\n";
			total_list << "{lrhls_track_secEta_s " << lrhls_track_secEta_s_depth << "}\n";
			total_list << "{lrhls_track_secPhi_s " << lrhls_track_secPhi_s_depth << "}\n";
			total_list << "{lrhls_track_qOverPt_s " << lrhls_track_qOverPt_s_depth << "}\n";
			total_list << "{lrhls_track_phi_s " << lrhls_track_phi_s_depth << "}\n";
			total_list << "{lrhls_track_z_s " << lrhls_track_z_s_depth << "}\n";
			total_list << "{lrhls_track_cot_s " << lrhls_track_cot_s_depth << "}\n";
			total_list << "{lrhls_secPhi_s " << lrhls_secPhi_s_depth << "}\n";
			total_list << "{lrhls_secEta_s " << lrhls_secEta_s_depth << "}\n";
			total_list << "{lrhls_HTParameter_qOverPt " << lrhls_HTParameter_qOverPt_depth << "}\n";
			total_list << "{lrhls_HTParameter_phiT " << lrhls_HTParameter_phiT_depth << "}\n";
			total_list << "{lrhls_HTParameter_cotTheta " << lrhls_HTParameter_cotTheta_depth << "}\n";
			total_list << "{lrhls_HTParameter_zT " << lrhls_HTParameter_zT_depth << "}\n";
			total_list << "{lrhls_LRParameter_qOverPt " << lrhls_LRParameter_qOverPt_depth << "}\n";
			total_list << "{lrhls_LRParameter_phiT " << lrhls_LRParameter_phiT_depth << "}\n";
			total_list << "{lrhls_LRParameter_cotTheta " << lrhls_LRParameter_cotTheta_depth << "}\n";
			total_list << "{lrhls_LRParameter_zT " << lrhls_LRParameter_zT_depth << "}\n";
			total_list << "{lrhls_stubs_size_s " << lrhls_stubs_size_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrNumIterations_s " << lrhls_stubs_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrMinLayers_s " << lrhls_stubs_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrMinLayersPS_s " << lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrResidPhi_s " << lrhls_stubs_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrResidZ2S_s " << lrhls_stubs_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_lrResidZPS_s " << lrhls_stubs_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_chosenRofPhi_s " << lrhls_stubs_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_chosenRofZ_s " << lrhls_stubs_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_invPtToDphi_s " << lrhls_stubs_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_settingsHLS_trackerNumLayers_s " << lrhls_stubs_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s " << lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s " << lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s " << lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s " << lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s " << lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_barrel_s " << lrhls_stubs_data_moduleHLS_barrel_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_psModule_s " << lrhls_stubs_data_moduleHLS_psModule_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_moduleHLS_layerId_s " << lrhls_stubs_data_moduleHLS_layerId_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_r_s " << lrhls_stubs_data_r_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_phi_s " << lrhls_stubs_data_phi_s_depth << "}\n";
			total_list << "{lrhls_stubs_data_z_s " << lrhls_stubs_data_z_s_depth << "}\n";
			total_list << "{lrhls_valid_s " << lrhls_valid_s_depth << "}\n";
			total_list << "{lrhls_stubMap_size_s " << lrhls_stubMap_size_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_first " << lrhls_stubMap_data_first_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_size_s " << lrhls_stubMap_data_second_size_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s " << lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s " << lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s " << lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s " << lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s " << lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s " << lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s " << lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s " << lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s " << lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s " << lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s " << lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_barrel_s " << lrhls_stubMap_data_second_data_moduleHLS_barrel_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_psModule_s " << lrhls_stubMap_data_second_data_moduleHLS_psModule_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_moduleHLS_layerId_s " << lrhls_stubMap_data_second_data_moduleHLS_layerId_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_r_s " << lrhls_stubMap_data_second_data_r_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_phi_s " << lrhls_stubMap_data_second_data_phi_s_depth << "}\n";
			total_list << "{lrhls_stubMap_data_second_data_z_s " << lrhls_stubMap_data_second_data_z_s_depth << "}\n";
			total_list << "{lrhls_layerPopulation_size_s " << lrhls_layerPopulation_size_s_depth << "}\n";
			total_list << "{lrhls_layerPopulation_data_first " << lrhls_layerPopulation_data_first_depth << "}\n";
			total_list << "{lrhls_layerPopulation_data_second " << lrhls_layerPopulation_data_second_depth << "}\n";
			total_list << "{lrhls_residuals_size_s " << lrhls_residuals_size_s_depth << "}\n";
			total_list << "{lrhls_residuals_data_first " << lrhls_residuals_data_first_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_size_s " << lrhls_residuals_data_second_size_s_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_data_phi " << lrhls_residuals_data_second_data_phi_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_data_z " << lrhls_residuals_data_second_data_z_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_data_layerId " << lrhls_residuals_data_second_data_layerId_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_data_stubId " << lrhls_residuals_data_second_data_stubId_depth << "}\n";
			total_list << "{lrhls_residuals_data_second_data_ps " << lrhls_residuals_data_second_data_ps_depth << "}\n";
			total_list << "{lrhls_largestResid_phi " << lrhls_largestResid_phi_depth << "}\n";
			total_list << "{lrhls_largestResid_z " << lrhls_largestResid_z_depth << "}\n";
			total_list << "{lrhls_largestResid_layerId " << lrhls_largestResid_layerId_depth << "}\n";
			total_list << "{lrhls_largestResid_stubId " << lrhls_largestResid_stubId_depth << "}\n";
			total_list << "{lrhls_largestResid_ps " << lrhls_largestResid_ps_depth << "}\n";
			total_list << "{lrhls_nIterations_s " << lrhls_nIterations_s_depth << "}\n";
			return total_list.str();
		}

		void set_num (int num , int* class_num) {
			(*class_num) = (*class_num) > num ? (*class_num) : num;
		}
	public:
		int lrhls_settings_chosenRofPhi_s_depth;
		int lrhls_settings_chosenRofZ_s_depth;
		int lrhls_settings_invPtToDphi_s_depth;
		int lrhls_data_tracksMHTHLS_size_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_depth;
		int lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_depth;
		int lrhls_data_tracksMHTHLS_data_secEta_s_depth;
		int lrhls_data_tracksMHTHLS_data_secPhi_s_depth;
		int lrhls_data_tracksMHTHLS_data_qOverPt_s_depth;
		int lrhls_data_tracksMHTHLS_data_phi_s_depth;
		int lrhls_data_tracksMHTHLS_data_z_s_depth;
		int lrhls_data_tracksMHTHLS_data_cot_s_depth;
		int lrhls_data_tracksLRHLS_size_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_size_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_depth;
		int lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_depth;
		int lrhls_data_tracksLRHLS_data_secEta_s_depth;
		int lrhls_data_tracksLRHLS_data_secPhi_s_depth;
		int lrhls_data_tracksLRHLS_data_qOverPt_s_depth;
		int lrhls_data_tracksLRHLS_data_phi_s_depth;
		int lrhls_data_tracksLRHLS_data_z_s_depth;
		int lrhls_data_tracksLRHLS_data_cot_s_depth;
		int lrhls_numLayers_s_depth;
		int lrhls_minLayers_s_depth;
		int lrhls_minLayersPS_s_depth;
		int lrhls_residPhi_s_depth;
		int lrhls_residZ2S_s_depth;
		int lrhls_residZPS_s_depth;
		int lrhls_maxIteartions_s_depth;
		int lrhls_track_settingsHLS_lrNumIterations_s_depth;
		int lrhls_track_settingsHLS_lrMinLayers_s_depth;
		int lrhls_track_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_track_settingsHLS_lrResidPhi_s_depth;
		int lrhls_track_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_track_settingsHLS_lrResidZPS_s_depth;
		int lrhls_track_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_track_settingsHLS_chosenRofZ_s_depth;
		int lrhls_track_settingsHLS_invPtToDphi_s_depth;
		int lrhls_track_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_track_stubsHLS_size_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_barrel_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_psModule_s_depth;
		int lrhls_track_stubsHLS_data_moduleHLS_layerId_s_depth;
		int lrhls_track_stubsHLS_data_r_s_depth;
		int lrhls_track_stubsHLS_data_phi_s_depth;
		int lrhls_track_stubsHLS_data_z_s_depth;
		int lrhls_track_secEta_s_depth;
		int lrhls_track_secPhi_s_depth;
		int lrhls_track_qOverPt_s_depth;
		int lrhls_track_phi_s_depth;
		int lrhls_track_z_s_depth;
		int lrhls_track_cot_s_depth;
		int lrhls_secPhi_s_depth;
		int lrhls_secEta_s_depth;
		int lrhls_HTParameter_qOverPt_depth;
		int lrhls_HTParameter_phiT_depth;
		int lrhls_HTParameter_cotTheta_depth;
		int lrhls_HTParameter_zT_depth;
		int lrhls_LRParameter_qOverPt_depth;
		int lrhls_LRParameter_phiT_depth;
		int lrhls_LRParameter_cotTheta_depth;
		int lrhls_LRParameter_zT_depth;
		int lrhls_stubs_size_s_depth;
		int lrhls_stubs_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_stubs_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_stubs_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_stubs_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_stubs_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_stubs_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_stubs_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_stubs_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_stubs_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_depth;
		int lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_stubs_data_moduleHLS_barrel_s_depth;
		int lrhls_stubs_data_moduleHLS_psModule_s_depth;
		int lrhls_stubs_data_moduleHLS_layerId_s_depth;
		int lrhls_stubs_data_r_s_depth;
		int lrhls_stubs_data_phi_s_depth;
		int lrhls_stubs_data_z_s_depth;
		int lrhls_valid_s_depth;
		int lrhls_stubMap_size_s_depth;
		int lrhls_stubMap_data_first_depth;
		int lrhls_stubMap_data_second_size_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_depth;
		int lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_barrel_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_psModule_s_depth;
		int lrhls_stubMap_data_second_data_moduleHLS_layerId_s_depth;
		int lrhls_stubMap_data_second_data_r_s_depth;
		int lrhls_stubMap_data_second_data_phi_s_depth;
		int lrhls_stubMap_data_second_data_z_s_depth;
		int lrhls_layerPopulation_size_s_depth;
		int lrhls_layerPopulation_data_first_depth;
		int lrhls_layerPopulation_data_second_depth;
		int lrhls_residuals_size_s_depth;
		int lrhls_residuals_data_first_depth;
		int lrhls_residuals_data_second_size_s_depth;
		int lrhls_residuals_data_second_data_phi_depth;
		int lrhls_residuals_data_second_data_z_depth;
		int lrhls_residuals_data_second_data_layerId_depth;
		int lrhls_residuals_data_second_data_stubId_depth;
		int lrhls_residuals_data_second_data_ps_depth;
		int lrhls_largestResid_phi_depth;
		int lrhls_largestResid_z_depth;
		int lrhls_largestResid_layerId_depth;
		int lrhls_largestResid_stubId_depth;
		int lrhls_largestResid_ps_depth;
		int lrhls_nIterations_s_depth;
		int trans_num;

	private:
		ofstream mFile;
		const char* mName;
};

extern void LR_top (
TMTT::LRHLS lrhls);

void AESL_WRAP_LR_top (
TMTT::LRHLS lrhls)
{
	refine_signal_handler();
	fstream wrapc_switch_file_token;
	wrapc_switch_file_token.open(".hls_cosim_wrapc_switch.log");
	int AESL_i;
	if (wrapc_switch_file_token.good())
	{
		CodeState = ENTER_WRAPC_PC;
		static unsigned AESL_transaction_pc = 0;
		string AESL_token;
		string AESL_num;
		static AESL_FILE_HANDLER aesl_fh;


		// output port post check: "lrhls_track_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrNumIterations__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrNumIterations__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrNumIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrNumIterations_
								// output_left_conversion : lrhls.track_.settingsHLS_.lrNumIterations_
								// output_type_conversion : (lrhls_track__settingsHLS__lrNumIterations__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.settingsHLS_.lrNumIterations_ = (lrhls_track__settingsHLS__lrNumIterations__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrMinLayers__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrMinLayers__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrMinLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrMinLayers_
								// output_left_conversion : lrhls.track_.settingsHLS_.lrMinLayers_
								// output_type_conversion : (lrhls_track__settingsHLS__lrMinLayers__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.settingsHLS_.lrMinLayers_ = (lrhls_track__settingsHLS__lrMinLayers__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrMinLayersPS__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrMinLayersPS__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrMinLayersPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrMinLayersPS_
								// output_left_conversion : lrhls.track_.settingsHLS_.lrMinLayersPS_
								// output_type_conversion : (lrhls_track__settingsHLS__lrMinLayersPS__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.settingsHLS_.lrMinLayersPS_ = (lrhls_track__settingsHLS__lrMinLayersPS__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrResidPhi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrResidPhi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrResidPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrResidPhi_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidPhi_
								// output_type_conversion : (lrhls_track__settingsHLS__lrResidPhi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.lrResidPhi_ = (lrhls_track__settingsHLS__lrResidPhi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrResidZ2S__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrResidZ2S__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrResidZ2S_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrResidZ2S_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_
								// output_type_conversion : (lrhls_track__settingsHLS__lrResidZ2S__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_ = (lrhls_track__settingsHLS__lrResidZ2S__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__lrResidZPS__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__lrResidZPS__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.lrResidZPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.lrResidZPS_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZPS_
								// output_type_conversion : (lrhls_track__settingsHLS__lrResidZPS__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.lrResidZPS_ = (lrhls_track__settingsHLS__lrResidZPS__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__chosenRofPhi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__chosenRofPhi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.chosenRofPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.chosenRofPhi_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_
								// output_type_conversion : (lrhls_track__settingsHLS__chosenRofPhi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_ = (lrhls_track__settingsHLS__chosenRofPhi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__chosenRofZ__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__chosenRofZ__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.chosenRofZ_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.chosenRofZ_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofZ_
								// output_type_conversion : (lrhls_track__settingsHLS__chosenRofZ__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.chosenRofZ_ = (lrhls_track__settingsHLS__chosenRofZ__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__invPtToDphi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__invPtToDphi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.invPtToDphi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.invPtToDphi_
								// output_left_conversion : *(int*)&lrhls.track_.settingsHLS_.invPtToDphi_
								// output_type_conversion : (lrhls_track__settingsHLS__invPtToDphi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.settingsHLS_.invPtToDphi_ = (lrhls_track__settingsHLS__invPtToDphi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__settingsHLS__trackerNumLayers__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__settingsHLS__trackerNumLayers__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.settingsHLS_.trackerNumLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.settingsHLS_.trackerNumLayers_
								// output_left_conversion : lrhls.track_.settingsHLS_.trackerNumLayers_
								// output_type_conversion : (lrhls_track__settingsHLS__trackerNumLayers__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.settingsHLS_.trackerNumLayers_ = (lrhls_track__settingsHLS__trackerNumLayers__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_size_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.size_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__size__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__size__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.size_
								// output_left_conversion : lrhls.track_.stubsHLS_.size_
								// output_type_conversion : (lrhls_track__stubsHLS__size__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.size_ = (lrhls_track__stubsHLS__size__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_size_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_ = (lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_ = (lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_ = (lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_ = (lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_ = (lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_ = (lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_ = (lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_ = (lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_ = (lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
								// output_type_conversion : (lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_ = (lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_ = (lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_barrel_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, AESL_token); // data

			sc_bv<1> *lrhls_track_stubsHLS_data_moduleHLS_barrel_s_pc_buffer = new sc_bv<1>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_barrel_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_barrel_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_barrel_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
						// {
							sc_lv<1>* lrhls_track__stubsHLS__data__moduleHLS__barrel__lv0_0_15_1 = new sc_lv<1>[16];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_track_stubsHLS_data_moduleHLS_barrel_s_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_ = (lrhls_track__stubsHLS__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_barrel_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_psModule_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, AESL_token); // data

			sc_bv<1> *lrhls_track_stubsHLS_data_moduleHLS_psModule_s_pc_buffer = new sc_bv<1>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_psModule_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_psModule_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_psModule_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
						// {
							sc_lv<1>* lrhls_track__stubsHLS__data__moduleHLS__psModule__lv0_0_15_1 = new sc_lv<1>[16];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_track_stubsHLS_data_moduleHLS_psModule_s_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_ = (lrhls_track__stubsHLS__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_psModule_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_moduleHLS_layerId_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_moduleHLS_layerId_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_moduleHLS_layerId_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_moduleHLS_layerId_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_layerId_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__moduleHLS__layerId__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_moduleHLS_layerId_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_
								// output_left_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
								// output_type_conversion : (lrhls_track__stubsHLS__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_ = (lrhls_track__stubsHLS__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_moduleHLS_layerId_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_r_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_r_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_r_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_r_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_r_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.r_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__r__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.r_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__r__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_r_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.r_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].r_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].r_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_
								// output_type_conversion : (lrhls_track__stubsHLS__data__r__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_ = (lrhls_track__stubsHLS__data__r__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_r_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_phi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_phi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_phi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_phi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_phi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.phi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__phi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.phi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__phi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_phi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.phi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].phi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].phi_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_
								// output_type_conversion : (lrhls_track__stubsHLS__data__phi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_ = (lrhls_track__stubsHLS__data__phi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_phi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_stubsHLS_data_z_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s, AESL_token); // data

			sc_bv<32> *lrhls_track_stubsHLS_data_z_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_stubsHLS_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_stubsHLS_data_z_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_stubsHLS_data_z_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_stubsHLS_data_z_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.stubsHLS_.data_.z_(31, 0)
						// {
							sc_lv<32>* lrhls_track__stubsHLS__data__z__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.z_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.track_.stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__stubsHLS__data__z__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_stubsHLS_data_z_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.stubsHLS_.data_.z_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.stubsHLS_.data_[i_0].z_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.stubsHLS_.data_[0].z_
								// output_left_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_
								// output_type_conversion : (lrhls_track__stubsHLS__data__z__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_ = (lrhls_track__stubsHLS__data__z__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_stubsHLS_data_z_s_pc_buffer;
		}

		// output port post check: "lrhls_track_secEta_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secEta_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secEta_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secEta_s, AESL_token); // data

			sc_bv<32> *lrhls_track_secEta_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_secEta_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_secEta_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_secEta_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secEta_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_secEta_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_secEta_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.secEta_(31, 0)
						// {
							sc_lv<32>* lrhls_track__secEta__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.secEta_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.secEta_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__secEta__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_secEta_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.secEta_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.secEta_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.secEta_
								// output_left_conversion : lrhls.track_.secEta_
								// output_type_conversion : (lrhls_track__secEta__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.secEta_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.secEta_ = (lrhls_track__secEta__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_secEta_s_pc_buffer;
		}

		// output port post check: "lrhls_track_secPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_secPhi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_secPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_secPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_secPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_secPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_secPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_secPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.secPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__secPhi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.secPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.secPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__secPhi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_secPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.secPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.secPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.secPhi_
								// output_left_conversion : lrhls.track_.secPhi_
								// output_type_conversion : (lrhls_track__secPhi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.secPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.track_.secPhi_ = (lrhls_track__secPhi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_secPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_qOverPt_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s, AESL_token); // data

			sc_bv<32> *lrhls_track_qOverPt_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_qOverPt_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_qOverPt_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_qOverPt_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_qOverPt_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_qOverPt_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.qOverPt_(31, 0)
						// {
							sc_lv<32>* lrhls_track__qOverPt__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.qOverPt_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.qOverPt_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__qOverPt__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_qOverPt_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.qOverPt_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.qOverPt_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.qOverPt_
								// output_left_conversion : *(int*)&lrhls.track_.qOverPt_
								// output_type_conversion : (lrhls_track__qOverPt__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.qOverPt_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.qOverPt_ = (lrhls_track__qOverPt__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_qOverPt_s_pc_buffer;
		}

		// output port post check: "lrhls_track_phi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_phi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_phi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_phi_s, AESL_token); // data

			sc_bv<32> *lrhls_track_phi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_phi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_phi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_phi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_phi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.phi_(31, 0)
						// {
							sc_lv<32>* lrhls_track__phi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.phi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.phi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__phi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_phi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.phi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.phi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.phi_
								// output_left_conversion : *(int*)&lrhls.track_.phi_
								// output_type_conversion : (lrhls_track__phi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.phi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.phi_ = (lrhls_track__phi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_phi_s_pc_buffer;
		}

		// output port post check: "lrhls_track_z_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_z_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_z_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_z_s, AESL_token); // data

			sc_bv<32> *lrhls_track_z_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_z_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_z_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_z_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_z_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.z_(31, 0)
						// {
							sc_lv<32>* lrhls_track__z__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.z_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.z_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__z__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_z_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.z_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.z_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.z_
								// output_left_conversion : *(int*)&lrhls.track_.z_
								// output_type_conversion : (lrhls_track__z__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.z_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.z_ = (lrhls_track__z__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_z_s_pc_buffer;
		}

		// output port post check: "lrhls_track_cot_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_cot_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_cot_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_cot_s, AESL_token); // data

			sc_bv<32> *lrhls_track_cot_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_cot_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_track_cot_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_track_cot_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_track_cot_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_track_cot_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_track_cot_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.track_.cot_(31, 0)
						// {
							sc_lv<32>* lrhls_track__cot__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.cot_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.track_.cot_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_track__cot__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_track_cot_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.track_.cot_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.track_.cot_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.track_.cot_
								// output_left_conversion : *(int*)&lrhls.track_.cot_
								// output_type_conversion : (lrhls_track__cot__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.track_.cot_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.track_.cot_ = (lrhls_track__cot__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_track_cot_s_pc_buffer;
		}

		// output port post check: "lrhls_secPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_secPhi_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_secPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_secPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_secPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_secPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_secPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.secPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_secPhi__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.secPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.secPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_secPhi__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_secPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.secPhi_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.secPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.secPhi_
								// output_left_conversion : lrhls.secPhi_
								// output_type_conversion : (lrhls_secPhi__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.secPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.secPhi_ = (lrhls_secPhi__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_secPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_secEta_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secEta_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secEta_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secEta_s, AESL_token); // data

			sc_bv<32> *lrhls_secEta_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_secEta_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_secEta_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_secEta_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_secEta_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_secEta_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_secEta_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.secEta_(31, 0)
						// {
							sc_lv<32>* lrhls_secEta__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.secEta_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.secEta_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_secEta__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_secEta_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.secEta_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.secEta_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.secEta_
								// output_left_conversion : lrhls.secEta_
								// output_type_conversion : (lrhls_secEta__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.secEta_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.secEta_ = (lrhls_secEta__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_secEta_s_pc_buffer;
		}

		// output port post check: "lrhls_HTParameter_qOverPt"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt, AESL_token); // data

			sc_bv<32> *lrhls_HTParameter_qOverPt_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_qOverPt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_qOverPt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_HTParameter_qOverPt_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_HTParameter_qOverPt))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_HTParameter_qOverPt
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.HTParameter_.qOverPt(31, 0)
						// {
							sc_lv<32>* lrhls_HTParameter__qOverPt_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.qOverPt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.HTParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
								{
									lrhls_HTParameter__qOverPt_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_HTParameter_qOverPt_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.qOverPt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.HTParameter_.qOverPt
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.HTParameter_.qOverPt
								// output_left_conversion : *(int*)&lrhls.HTParameter_.qOverPt
								// output_type_conversion : (lrhls_HTParameter__qOverPt_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.HTParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.HTParameter_.qOverPt = (lrhls_HTParameter__qOverPt_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_HTParameter_qOverPt_pc_buffer;
		}

		// output port post check: "lrhls_HTParameter_phiT"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT, AESL_token); // data

			sc_bv<32> *lrhls_HTParameter_phiT_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_phiT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_phiT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_HTParameter_phiT_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_HTParameter_phiT))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_HTParameter_phiT
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.HTParameter_.phiT(31, 0)
						// {
							sc_lv<32>* lrhls_HTParameter__phiT_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.phiT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.HTParameter_.phiT) != NULL) // check the null address if the c port is array or others
								{
									lrhls_HTParameter__phiT_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_HTParameter_phiT_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.phiT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.HTParameter_.phiT
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.HTParameter_.phiT
								// output_left_conversion : *(int*)&lrhls.HTParameter_.phiT
								// output_type_conversion : (lrhls_HTParameter__phiT_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.HTParameter_.phiT) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.HTParameter_.phiT = (lrhls_HTParameter__phiT_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_HTParameter_phiT_pc_buffer;
		}

		// output port post check: "lrhls_HTParameter_cotTheta"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta, AESL_token); // data

			sc_bv<32> *lrhls_HTParameter_cotTheta_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_cotTheta', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_cotTheta', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_HTParameter_cotTheta_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_HTParameter_cotTheta))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_HTParameter_cotTheta
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.HTParameter_.cotTheta(31, 0)
						// {
							sc_lv<32>* lrhls_HTParameter__cotTheta_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.cotTheta(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.HTParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
								{
									lrhls_HTParameter__cotTheta_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_HTParameter_cotTheta_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.cotTheta(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.HTParameter_.cotTheta
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.HTParameter_.cotTheta
								// output_left_conversion : *(int*)&lrhls.HTParameter_.cotTheta
								// output_type_conversion : (lrhls_HTParameter__cotTheta_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.HTParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.HTParameter_.cotTheta = (lrhls_HTParameter__cotTheta_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_HTParameter_cotTheta_pc_buffer;
		}

		// output port post check: "lrhls_HTParameter_zT"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_zT, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_zT, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_zT, AESL_token); // data

			sc_bv<32> *lrhls_HTParameter_zT_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_zT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_HTParameter_zT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_HTParameter_zT_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_HTParameter_zT, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_HTParameter_zT))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_HTParameter_zT
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.HTParameter_.zT(31, 0)
						// {
							sc_lv<32>* lrhls_HTParameter__zT_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.zT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.HTParameter_.zT) != NULL) // check the null address if the c port is array or others
								{
									lrhls_HTParameter__zT_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_HTParameter_zT_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.HTParameter_.zT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.HTParameter_.zT
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.HTParameter_.zT
								// output_left_conversion : *(int*)&lrhls.HTParameter_.zT
								// output_type_conversion : (lrhls_HTParameter__zT_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.HTParameter_.zT) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.HTParameter_.zT = (lrhls_HTParameter__zT_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_HTParameter_zT_pc_buffer;
		}

		// output port post check: "lrhls_LRParameter_qOverPt"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt, AESL_token); // data

			sc_bv<32> *lrhls_LRParameter_qOverPt_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_qOverPt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_qOverPt', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_LRParameter_qOverPt_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_LRParameter_qOverPt))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_LRParameter_qOverPt
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.LRParameter_.qOverPt(31, 0)
						// {
							sc_lv<32>* lrhls_LRParameter__qOverPt_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.qOverPt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.LRParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
								{
									lrhls_LRParameter__qOverPt_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_LRParameter_qOverPt_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.qOverPt(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.LRParameter_.qOverPt
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.LRParameter_.qOverPt
								// output_left_conversion : *(int*)&lrhls.LRParameter_.qOverPt
								// output_type_conversion : (lrhls_LRParameter__qOverPt_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.LRParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.LRParameter_.qOverPt = (lrhls_LRParameter__qOverPt_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_LRParameter_qOverPt_pc_buffer;
		}

		// output port post check: "lrhls_LRParameter_phiT"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT, AESL_token); // data

			sc_bv<32> *lrhls_LRParameter_phiT_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_phiT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_phiT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_LRParameter_phiT_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_LRParameter_phiT))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_LRParameter_phiT
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.LRParameter_.phiT(31, 0)
						// {
							sc_lv<32>* lrhls_LRParameter__phiT_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.phiT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.LRParameter_.phiT) != NULL) // check the null address if the c port is array or others
								{
									lrhls_LRParameter__phiT_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_LRParameter_phiT_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.phiT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.LRParameter_.phiT
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.LRParameter_.phiT
								// output_left_conversion : *(int*)&lrhls.LRParameter_.phiT
								// output_type_conversion : (lrhls_LRParameter__phiT_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.LRParameter_.phiT) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.LRParameter_.phiT = (lrhls_LRParameter__phiT_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_LRParameter_phiT_pc_buffer;
		}

		// output port post check: "lrhls_LRParameter_cotTheta"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta, AESL_token); // data

			sc_bv<32> *lrhls_LRParameter_cotTheta_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_cotTheta', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_cotTheta', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_LRParameter_cotTheta_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_LRParameter_cotTheta))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_LRParameter_cotTheta
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.LRParameter_.cotTheta(31, 0)
						// {
							sc_lv<32>* lrhls_LRParameter__cotTheta_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.cotTheta(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.LRParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
								{
									lrhls_LRParameter__cotTheta_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_LRParameter_cotTheta_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.cotTheta(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.LRParameter_.cotTheta
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.LRParameter_.cotTheta
								// output_left_conversion : *(int*)&lrhls.LRParameter_.cotTheta
								// output_type_conversion : (lrhls_LRParameter__cotTheta_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.LRParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.LRParameter_.cotTheta = (lrhls_LRParameter__cotTheta_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_LRParameter_cotTheta_pc_buffer;
		}

		// output port post check: "lrhls_LRParameter_zT"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_zT, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_zT, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_zT, AESL_token); // data

			sc_bv<32> *lrhls_LRParameter_zT_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_zT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_LRParameter_zT', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_LRParameter_zT_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_LRParameter_zT, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_LRParameter_zT))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_LRParameter_zT
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.LRParameter_.zT(31, 0)
						// {
							sc_lv<32>* lrhls_LRParameter__zT_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.zT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.LRParameter_.zT) != NULL) // check the null address if the c port is array or others
								{
									lrhls_LRParameter__zT_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_LRParameter_zT_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.LRParameter_.zT(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.LRParameter_.zT
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.LRParameter_.zT
								// output_left_conversion : *(int*)&lrhls.LRParameter_.zT
								// output_type_conversion : (lrhls_LRParameter__zT_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.LRParameter_.zT) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.LRParameter_.zT = (lrhls_LRParameter__zT_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_LRParameter_zT_pc_buffer;
		}

		// output port post check: "lrhls_stubs_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_size_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_size_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.size_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__size__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.stubs_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__size__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.size_
								// output_left_conversion : lrhls.stubs_.size_
								// output_type_conversion : (lrhls_stubs__size__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.size_ = (lrhls_stubs__size__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_size_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrNumIterations__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_
								// output_left_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_ = (lrhls_stubs__data__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrMinLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_
								// output_left_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_ = (lrhls_stubs__data__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrMinLayersPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_
								// output_left_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_ = (lrhls_stubs__data__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrResidPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_ = (lrhls_stubs__data__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrResidZ2S__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_ = (lrhls_stubs__data__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__lrResidZPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_ = (lrhls_stubs__data__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__chosenRofPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_ = (lrhls_stubs__data__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__chosenRofZ__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_ = (lrhls_stubs__data__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__invPtToDphi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_ = (lrhls_stubs__data__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__settingsHLS__trackerNumLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_
								// output_left_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
								// output_type_conversion : (lrhls_stubs__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_ = (lrhls_stubs__data__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_ = (lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_ = (lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_ = (lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_ = (lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_ = (lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_barrel_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s, AESL_token); // data

			sc_bv<1> *lrhls_stubs_data_moduleHLS_barrel_s_pc_buffer = new sc_bv<1>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_barrel_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_barrel_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_barrel_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.barrel_(0, 0)
						// {
							sc_lv<1>* lrhls_stubs__data__moduleHLS__barrel__lv0_0_15_1 = new sc_lv<1>[16];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_stubs_data_moduleHLS_barrel_s_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.barrel_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.barrel_ = (lrhls_stubs__data__moduleHLS__barrel__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_barrel_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_psModule_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s, AESL_token); // data

			sc_bv<1> *lrhls_stubs_data_moduleHLS_psModule_s_pc_buffer = new sc_bv<1>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_psModule_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_psModule_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_psModule_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.psModule_(0, 0)
						// {
							sc_lv<1>* lrhls_stubs__data__moduleHLS__psModule__lv0_0_15_1 = new sc_lv<1>[16];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_stubs_data_moduleHLS_psModule_s_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.psModule_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.psModule_ = (lrhls_stubs__data__moduleHLS__psModule__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_psModule_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_moduleHLS_layerId_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_moduleHLS_layerId_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_moduleHLS_layerId_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_moduleHLS_layerId_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_moduleHLS_layerId_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.moduleHLS_.layerId_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__moduleHLS__layerId__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_moduleHLS_layerId_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].moduleHLS_.layerId_
								// output_left_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
								// output_type_conversion : (lrhls_stubs__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubs_.data_[i_0].moduleHLS_.layerId_ = (lrhls_stubs__data__moduleHLS__layerId__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_moduleHLS_layerId_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_r_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_r_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_r_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_r_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_r_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.r_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__r__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.r_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].r_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__r__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_r_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.r_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].r_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].r_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].r_
								// output_type_conversion : (lrhls_stubs__data__r__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].r_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].r_ = (lrhls_stubs__data__r__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_r_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_phi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_phi_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_phi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_phi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_phi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.phi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__phi__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.phi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__phi__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_phi_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.phi_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].phi_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].phi_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].phi_
								// output_type_conversion : (lrhls_stubs__data__phi__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].phi_ = (lrhls_stubs__data__phi__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_phi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubs_data_z_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s, AESL_token); // data

			sc_bv<32> *lrhls_stubs_data_z_s_pc_buffer = new sc_bv<32>[16];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubs_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubs_data_z_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubs_data_z_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubs_data_z_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubs_.data_.z_(31, 0)
						// {
							sc_lv<32>* lrhls_stubs__data__z__lv0_0_15_1 = new sc_lv<32>[16];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.z_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								if (&(lrhls.stubs_.data_[0].z_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubs__data__z__lv0_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubs_data_z_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubs_.data_.z_(31, 0)
						{
							// carray: (0) => (15) @ (1)
							for (int i_0 = 0; i_0 <= 15; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubs_.data_[i_0].z_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubs_.data_[0].z_
								// output_left_conversion : *(int*)&lrhls.stubs_.data_[i_0].z_
								// output_type_conversion : (lrhls_stubs__data__z__lv0_0_15_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubs_.data_[0].z_) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.stubs_.data_[i_0].z_ = (lrhls_stubs__data__z__lv0_0_15_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubs_data_z_s_pc_buffer;
		}

		// output port post check: "lrhls_valid_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_valid_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_valid_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_valid_s, AESL_token); // data

			sc_bv<1> *lrhls_valid_s_pc_buffer = new sc_bv<1>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_valid_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_valid_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_valid_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_valid_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_valid_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_valid_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.valid_(0, 0)
						// {
							sc_lv<1>* lrhls_valid__lv0_0_0_1 = new sc_lv<1>[1];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.valid_(0, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.valid_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_valid__lv0_0_0_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_valid_s_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.valid_(0, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.valid_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.valid_
								// output_left_conversion : lrhls.valid_
								// output_type_conversion : (lrhls_valid__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.valid_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.valid_ = (lrhls_valid__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_valid_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_size_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_size_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.size_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__size__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.stubMap_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubMap__size__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubMap_.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubMap_.size_
								// output_left_conversion : lrhls.stubMap_.size_
								// output_type_conversion : (lrhls_stubMap__size__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubMap_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubMap_.size_ = (lrhls_stubMap__size__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_size_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_first"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_first, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_first, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_first, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_first_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_first_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_first, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_first))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_first
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.first(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__first_lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.stubMap_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubMap__data__first_lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_first_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubMap_.data_[i_0].first
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubMap_.data_[0].first
								// output_left_conversion : lrhls.stubMap_.data_[i_0].first
								// output_type_conversion : (lrhls_stubMap__data__first_lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubMap_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubMap_.data_[i_0].first = (lrhls_stubMap__data__first_lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_first_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_size_s_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.size_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_size__lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.size_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.stubMap_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_stubMap__data__second_size__lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.size_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.stubMap_.data_[i_0].second.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.size_
								// output_left_conversion : lrhls.stubMap_.data_[i_0].second.size_
								// output_type_conversion : (lrhls_stubMap__data__second_size__lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.stubMap_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.stubMap_.data_[i_0].second.size_ = (lrhls_stubMap__data__second_size__lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_size_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_ = (lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_ = (lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_ = (lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_ = (lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_ = (lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_ = (lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_ = (lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_ = (lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_ = (lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
									// output_type_conversion : (lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_ = (lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_ = (lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_barrel_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, AESL_token); // data

			sc_bv<1> *lrhls_stubMap_data_second_data_moduleHLS_barrel_s_pc_buffer = new sc_bv<1>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_barrel_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_barrel_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_barrel_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_barrel_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.barrel_(0, 0)
						// {
							sc_lv<1>* lrhls_stubMap__data__second_data__moduleHLS__barrel__lv0_0_29_1_lv1_0_15_1 = new sc_lv<1>[480];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__barrel__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_stubMap_data_second_data_moduleHLS_barrel_s_pc_buffer[hls_map_index].range(0, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.barrel_(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__barrel__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_ = (lrhls_stubMap__data__second_data__moduleHLS__barrel__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_barrel_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_psModule_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, AESL_token); // data

			sc_bv<1> *lrhls_stubMap_data_second_data_moduleHLS_psModule_s_pc_buffer = new sc_bv<1>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_psModule_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_psModule_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_psModule_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_psModule_s
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.psModule_(0, 0)
						// {
							sc_lv<1>* lrhls_stubMap__data__second_data__moduleHLS__psModule__lv0_0_29_1_lv1_0_15_1 = new sc_lv<1>[480];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__psModule__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_stubMap_data_second_data_moduleHLS_psModule_s_pc_buffer[hls_map_index].range(0, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.psModule_(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__psModule__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_ = (lrhls_stubMap__data__second_data__moduleHLS__psModule__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_psModule_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_moduleHLS_layerId_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_moduleHLS_layerId_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_moduleHLS_layerId_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_moduleHLS_layerId_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_moduleHLS_layerId_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_layerId_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.layerId_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__moduleHLS__layerId__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__moduleHLS__layerId__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_moduleHLS_layerId_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.layerId_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_
									// output_left_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
									// output_type_conversion : (lrhls_stubMap__data__second_data__moduleHLS__layerId__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
									{
										lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_ = (lrhls_stubMap__data__second_data__moduleHLS__layerId__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_moduleHLS_layerId_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_r_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_r_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_r_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_r_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_r_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_r_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.r_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__r__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.r_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].r_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__r__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_r_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.r_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].r_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
									// output_type_conversion : (lrhls_stubMap__data__second_data__r__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].r_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_ = (lrhls_stubMap__data__second_data__r__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_r_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_phi_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_phi_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_phi_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_phi_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_phi_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_phi_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.phi_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__phi__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.phi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].phi_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__phi__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_phi_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.phi_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].phi_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
									// output_type_conversion : (lrhls_stubMap__data__second_data__phi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].phi_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_ = (lrhls_stubMap__data__second_data__phi__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_phi_s_pc_buffer;
		}

		// output port post check: "lrhls_stubMap_data_second_data_z_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s, AESL_token); // data

			sc_bv<32> *lrhls_stubMap_data_second_data_z_s_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_stubMap_data_second_data_z_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_stubMap_data_second_data_z_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_stubMap_data_second_data_z_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_stubMap_data_second_data_z_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.stubMap_.data_.second.data_.z_(31, 0)
						// {
							sc_lv<32>* lrhls_stubMap__data__second_data__z__lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.z_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.stubMap_.data_[0].second.data_[0].z_) != NULL) // check the null address if the c port is array or others
									{
										lrhls_stubMap__data__second_data__z__lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_stubMap_data_second_data_z_s_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.stubMap_.data_.second.data_.z_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.stubMap_.data_[0].second.data_[0].z_
									// output_left_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
									// output_type_conversion : (lrhls_stubMap__data__second_data__z__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.stubMap_.data_[0].second.data_[0].z_) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_ = (lrhls_stubMap__data__second_data__z__lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_stubMap_data_second_data_z_s_pc_buffer;
		}

		// output port post check: "lrhls_layerPopulation_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s, AESL_token); // data

			sc_bv<32> *lrhls_layerPopulation_size_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_layerPopulation_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_layerPopulation_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_layerPopulation_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.layerPopulation_.size_(31, 0)
						// {
							sc_lv<32>* lrhls_layerPopulation__size__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.layerPopulation_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_layerPopulation__size__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_layerPopulation_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.layerPopulation_.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.layerPopulation_.size_
								// output_left_conversion : lrhls.layerPopulation_.size_
								// output_type_conversion : (lrhls_layerPopulation__size__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.layerPopulation_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.layerPopulation_.size_ = (lrhls_layerPopulation__size__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_layerPopulation_size_s_pc_buffer;
		}

		// output port post check: "lrhls_layerPopulation_data_first"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first, AESL_token); // data

			sc_bv<32> *lrhls_layerPopulation_data_first_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_layerPopulation_data_first_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_first))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_layerPopulation_data_first
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.layerPopulation_.data_.first(31, 0)
						// {
							sc_lv<32>* lrhls_layerPopulation__data__first_lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.layerPopulation_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls_layerPopulation__data__first_lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_layerPopulation_data_first_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.layerPopulation_.data_[i_0].first
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.layerPopulation_.data_[0].first
								// output_left_conversion : lrhls.layerPopulation_.data_[i_0].first
								// output_type_conversion : (lrhls_layerPopulation__data__first_lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.layerPopulation_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls.layerPopulation_.data_[i_0].first = (lrhls_layerPopulation__data__first_lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_layerPopulation_data_first_pc_buffer;
		}

		// output port post check: "lrhls_layerPopulation_data_second"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second, AESL_token); // data

			sc_bv<32> *lrhls_layerPopulation_data_second_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_data_second', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_layerPopulation_data_second', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_layerPopulation_data_second_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_layerPopulation_data_second))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_layerPopulation_data_second
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.layerPopulation_.data_.second(31, 0)
						// {
							sc_lv<32>* lrhls_layerPopulation__data__second_lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.data_.second(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.layerPopulation_.data_[0].second) != NULL) // check the null address if the c port is array or others
								{
									lrhls_layerPopulation__data__second_lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_layerPopulation_data_second_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.layerPopulation_.data_.second(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.layerPopulation_.data_[i_0].second
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.layerPopulation_.data_[0].second
								// output_left_conversion : lrhls.layerPopulation_.data_[i_0].second
								// output_type_conversion : (lrhls_layerPopulation__data__second_lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.layerPopulation_.data_[0].second) != NULL) // check the null address if the c port is array or others
								{
									lrhls.layerPopulation_.data_[i_0].second = (lrhls_layerPopulation__data__second_lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_layerPopulation_data_second_pc_buffer;
		}

		// output port post check: "lrhls_residuals_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_size_s, AESL_token); // data

			sc_bv<32> *lrhls_residuals_size_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.size_(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__size__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.residuals_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_residuals__size__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.size_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.residuals_.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.residuals_.size_
								// output_left_conversion : lrhls.residuals_.size_
								// output_type_conversion : (lrhls_residuals__size__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.residuals_.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.residuals_.size_ = (lrhls_residuals__size__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_size_s_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_first"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_first, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_first, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_first, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_first_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_first', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_first_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_first, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_first))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_first
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.first(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__first_lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.residuals_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls_residuals__data__first_lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_first_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.first(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.residuals_.data_[i_0].first
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.residuals_.data_[0].first
								// output_left_conversion : lrhls.residuals_.data_[i_0].first
								// output_type_conversion : (lrhls_residuals__data__first_lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.residuals_.data_[0].first) != NULL) // check the null address if the c port is array or others
								{
									lrhls.residuals_.data_[i_0].first = (lrhls_residuals__data__first_lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_first_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_size_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_second_size_s_pc_buffer = new sc_bv<32>[30];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_size_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_size_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_size_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_size_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.second.size_(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__second_size__lv0_0_29_1 = new sc_lv<32>[30];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.size_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								if (&(lrhls.residuals_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_residuals__data__second_size__lv0_0_29_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_second_size_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.size_(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.residuals_.data_[i_0].second.size_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.size_
								// output_left_conversion : lrhls.residuals_.data_[i_0].second.size_
								// output_type_conversion : (lrhls_residuals__data__second_size__lv0_0_29_1[hls_map_index]).to_uint64()
								if (&(lrhls.residuals_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.residuals_.data_[i_0].second.size_ = (lrhls_residuals__data__second_size__lv0_0_29_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_size_s_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_data_phi"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_second_data_phi_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_phi', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_phi', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_data_phi_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_phi))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_data_phi
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.second.data_.phi(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__second_data__phi_lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.phi(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.residuals_.data_[0].second.data_[0].phi) != NULL) // check the null address if the c port is array or others
									{
										lrhls_residuals__data__second_data__phi_lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_second_data_phi_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.phi(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.residuals_.data_[i_0].second.data_[i_1].phi
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.data_[0].phi
									// output_left_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi
									// output_type_conversion : (lrhls_residuals__data__second_data__phi_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.residuals_.data_[0].second.data_[0].phi) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi = (lrhls_residuals__data__second_data__phi_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_data_phi_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_data_z"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_second_data_z_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_z', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_z', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_data_z_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_z))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_data_z
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.second.data_.z(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__second_data__z_lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.z(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.residuals_.data_[0].second.data_[0].z) != NULL) // check the null address if the c port is array or others
									{
										lrhls_residuals__data__second_data__z_lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_second_data_z_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.z(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.residuals_.data_[i_0].second.data_[i_1].z
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.data_[0].z
									// output_left_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z
									// output_type_conversion : (lrhls_residuals__data__second_data__z_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.residuals_.data_[0].second.data_[0].z) != NULL) // check the null address if the c port is array or others
									{
										*(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z = (lrhls_residuals__data__second_data__z_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_data_z_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_data_layerId"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_second_data_layerId_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_layerId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_layerId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_data_layerId_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_layerId))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_data_layerId
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.second.data_.layerId(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__second_data__layerId_lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.layerId(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.residuals_.data_[0].second.data_[0].layerId) != NULL) // check the null address if the c port is array or others
									{
										lrhls_residuals__data__second_data__layerId_lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_second_data_layerId_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.layerId(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.data_[0].layerId
									// output_left_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
									// output_type_conversion : (lrhls_residuals__data__second_data__layerId_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.residuals_.data_[0].second.data_[0].layerId) != NULL) // check the null address if the c port is array or others
									{
										lrhls.residuals_.data_[i_0].second.data_[i_1].layerId = (lrhls_residuals__data__second_data__layerId_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_data_layerId_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_data_stubId"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId, AESL_token); // data

			sc_bv<32> *lrhls_residuals_data_second_data_stubId_pc_buffer = new sc_bv<32>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_stubId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_stubId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_data_stubId_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_stubId))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_data_stubId
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.residuals_.data_.second.data_.stubId(31, 0)
						// {
							sc_lv<32>* lrhls_residuals__data__second_data__stubId_lv0_0_29_1_lv1_0_15_1 = new sc_lv<32>[480];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.stubId(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.residuals_.data_[0].second.data_[0].stubId) != NULL) // check the null address if the c port is array or others
									{
										lrhls_residuals__data__second_data__stubId_lv0_0_29_1_lv1_0_15_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_residuals_data_second_data_stubId_pc_buffer[hls_map_index].range(31, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.stubId(31, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.data_[0].stubId
									// output_left_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
									// output_type_conversion : (lrhls_residuals__data__second_data__stubId_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.residuals_.data_[0].second.data_[0].stubId) != NULL) // check the null address if the c port is array or others
									{
										lrhls.residuals_.data_[i_0].second.data_[i_1].stubId = (lrhls_residuals__data__second_data__stubId_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_data_stubId_pc_buffer;
		}

		// output port post check: "lrhls_residuals_data_second_data_ps"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps, AESL_token); // data

			sc_bv<1> *lrhls_residuals_data_second_data_ps_pc_buffer = new sc_bv<1>[480];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_ps', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_residuals_data_second_data_ps', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_residuals_data_second_data_ps_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_residuals_data_second_data_ps))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_residuals_data_second_data_ps
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.residuals_.data_.second.data_.ps(0, 0)
						// {
							sc_lv<1>* lrhls_residuals__data__second_data__ps_lv0_0_29_1_lv1_0_15_1 = new sc_lv<1>[480];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.ps(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									if (&(lrhls.residuals_.data_[0].second.data_[0].ps) != NULL) // check the null address if the c port is array or others
									{
										lrhls_residuals__data__second_data__ps_lv0_0_29_1_lv1_0_15_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_residuals_data_second_data_ps_pc_buffer[hls_map_index].range(0, 0));
										hls_map_index++;
									}
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.residuals_.data_.second.data_.ps(0, 0)
						{
							// carray: (0) => (29) @ (1)
							for (int i_0 = 0; i_0 <= 29; i_0 += 1)
							{
								// carray: (0) => (15) @ (1)
								for (int i_1 = 0; i_1 <= 15; i_1 += 1)
								{
									// sub                    : i_0 i_1
									// ori_name               : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
									// sub_1st_elem           : 0 0
									// ori_name_1st_elem      : lrhls.residuals_.data_[0].second.data_[0].ps
									// output_left_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
									// output_type_conversion : (lrhls_residuals__data__second_data__ps_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64()
									if (&(lrhls.residuals_.data_[0].second.data_[0].ps) != NULL) // check the null address if the c port is array or others
									{
										lrhls.residuals_.data_[i_0].second.data_[i_1].ps = (lrhls_residuals__data__second_data__ps_lv0_0_29_1_lv1_0_15_1[hls_map_index]).to_uint64();
										hls_map_index++;
									}
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_residuals_data_second_data_ps_pc_buffer;
		}

		// output port post check: "lrhls_largestResid_phi"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_phi, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_phi, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_phi, AESL_token); // data

			sc_bv<32> *lrhls_largestResid_phi_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_phi', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_phi', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_largestResid_phi_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_phi, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_largestResid_phi))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_largestResid_phi
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.largestResid_.phi(31, 0)
						// {
							sc_lv<32>* lrhls_largestResid__phi_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.phi(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.largestResid_.phi) != NULL) // check the null address if the c port is array or others
								{
									lrhls_largestResid__phi_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_largestResid_phi_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.phi(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.largestResid_.phi
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.largestResid_.phi
								// output_left_conversion : *(int*)&lrhls.largestResid_.phi
								// output_type_conversion : (lrhls_largestResid__phi_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.largestResid_.phi) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.largestResid_.phi = (lrhls_largestResid__phi_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_largestResid_phi_pc_buffer;
		}

		// output port post check: "lrhls_largestResid_z"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_z, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_z, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_z, AESL_token); // data

			sc_bv<32> *lrhls_largestResid_z_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_z', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_z', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_largestResid_z_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_z, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_largestResid_z))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_largestResid_z
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.largestResid_.z(31, 0)
						// {
							sc_lv<32>* lrhls_largestResid__z_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.z(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.largestResid_.z) != NULL) // check the null address if the c port is array or others
								{
									lrhls_largestResid__z_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_largestResid_z_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.z(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.largestResid_.z
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.largestResid_.z
								// output_left_conversion : *(int*)&lrhls.largestResid_.z
								// output_type_conversion : (lrhls_largestResid__z_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.largestResid_.z) != NULL) // check the null address if the c port is array or others
								{
									*(int*)&lrhls.largestResid_.z = (lrhls_largestResid__z_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_largestResid_z_pc_buffer;
		}

		// output port post check: "lrhls_largestResid_layerId"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_layerId, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_layerId, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_layerId, AESL_token); // data

			sc_bv<32> *lrhls_largestResid_layerId_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_layerId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_layerId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_largestResid_layerId_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_layerId, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_largestResid_layerId))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_largestResid_layerId
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.largestResid_.layerId(31, 0)
						// {
							sc_lv<32>* lrhls_largestResid__layerId_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.layerId(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.largestResid_.layerId) != NULL) // check the null address if the c port is array or others
								{
									lrhls_largestResid__layerId_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_largestResid_layerId_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.layerId(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.largestResid_.layerId
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.largestResid_.layerId
								// output_left_conversion : lrhls.largestResid_.layerId
								// output_type_conversion : (lrhls_largestResid__layerId_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.largestResid_.layerId) != NULL) // check the null address if the c port is array or others
								{
									lrhls.largestResid_.layerId = (lrhls_largestResid__layerId_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_largestResid_layerId_pc_buffer;
		}

		// output port post check: "lrhls_largestResid_stubId"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_stubId, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_stubId, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_stubId, AESL_token); // data

			sc_bv<32> *lrhls_largestResid_stubId_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_stubId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_stubId', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_largestResid_stubId_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_stubId, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_largestResid_stubId))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_largestResid_stubId
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.largestResid_.stubId(31, 0)
						// {
							sc_lv<32>* lrhls_largestResid__stubId_lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.stubId(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.largestResid_.stubId) != NULL) // check the null address if the c port is array or others
								{
									lrhls_largestResid__stubId_lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_largestResid_stubId_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.stubId(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.largestResid_.stubId
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.largestResid_.stubId
								// output_left_conversion : lrhls.largestResid_.stubId
								// output_type_conversion : (lrhls_largestResid__stubId_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.largestResid_.stubId) != NULL) // check the null address if the c port is array or others
								{
									lrhls.largestResid_.stubId = (lrhls_largestResid__stubId_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_largestResid_stubId_pc_buffer;
		}

		// output port post check: "lrhls_largestResid_ps"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_ps, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_ps, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_ps, AESL_token); // data

			sc_bv<1> *lrhls_largestResid_ps_pc_buffer = new sc_bv<1>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_ps', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_largestResid_ps', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_largestResid_ps_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_largestResid_ps, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_largestResid_ps))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_largestResid_ps
				{
					// bitslice(0, 0)
					// {
						// celement: lrhls.largestResid_.ps(0, 0)
						// {
							sc_lv<1>* lrhls_largestResid__ps_lv0_0_0_1 = new sc_lv<1>[1];
						// }
					// }

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.ps(0, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.largestResid_.ps) != NULL) // check the null address if the c port is array or others
								{
									lrhls_largestResid__ps_lv0_0_0_1[hls_map_index].range(0, 0) = sc_bv<1>(lrhls_largestResid_ps_pc_buffer[hls_map_index].range(0, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(0, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.largestResid_.ps(0, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.largestResid_.ps
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.largestResid_.ps
								// output_left_conversion : lrhls.largestResid_.ps
								// output_type_conversion : (lrhls_largestResid__ps_lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.largestResid_.ps) != NULL) // check the null address if the c port is array or others
								{
									lrhls.largestResid_.ps = (lrhls_largestResid__ps_lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_largestResid_ps_pc_buffer;
		}

		// output port post check: "lrhls_nIterations_s"
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_nIterations_s, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_nIterations_s, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_nIterations_s, AESL_token); // data

			sc_bv<32> *lrhls_nIterations_s_pc_buffer = new sc_bv<32>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_nIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'lrhls_nIterations_s', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					lrhls_nIterations_s_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_lrhls_nIterations_s, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_lrhls_nIterations_s))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: lrhls_nIterations_s
				{
					// bitslice(31, 0)
					// {
						// celement: lrhls.nIterations_(31, 0)
						// {
							sc_lv<32>* lrhls_nIterations__lv0_0_0_1 = new sc_lv<32>[1];
						// }
					// }

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.nIterations_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								if (&(lrhls.nIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls_nIterations__lv0_0_0_1[hls_map_index].range(31, 0) = sc_bv<32>(lrhls_nIterations_s_pc_buffer[hls_map_index].range(31, 0));
									hls_map_index++;
								}
							}
						}
					}

					// bitslice(31, 0)
					{
						int hls_map_index = 0;
						// celement: lrhls.nIterations_(31, 0)
						{
							// carray: (0) => (0) @ (1)
							for (int i_0 = 0; i_0 <= 0; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : lrhls.nIterations_
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : lrhls.nIterations_
								// output_left_conversion : lrhls.nIterations_
								// output_type_conversion : (lrhls_nIterations__lv0_0_0_1[hls_map_index]).to_uint64()
								if (&(lrhls.nIterations_) != NULL) // check the null address if the c port is array or others
								{
									lrhls.nIterations_ = (lrhls_nIterations__lv0_0_0_1[hls_map_index]).to_uint64();
									hls_map_index++;
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] lrhls_nIterations_s_pc_buffer;
		}

		AESL_transaction_pc++;
	}
	else
	{
		CodeState = ENTER_WRAPC;
		static unsigned AESL_transaction;

		static AESL_FILE_HANDLER aesl_fh;

		// "lrhls_settings_chosenRofPhi_s"
		char* tvin_lrhls_settings_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_settings_chosenRofPhi_s);

		// "lrhls_settings_chosenRofZ_s"
		char* tvin_lrhls_settings_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_settings_chosenRofZ_s);

		// "lrhls_settings_invPtToDphi_s"
		char* tvin_lrhls_settings_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_settings_invPtToDphi_s);

		// "lrhls_data_tracksMHTHLS_size_s"
		char* tvin_lrhls_data_tracksMHTHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_size_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_size_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s);

		// "lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s);

		// "lrhls_data_tracksMHTHLS_data_secEta_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_secEta_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secEta_s);

		// "lrhls_data_tracksMHTHLS_data_secPhi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_secPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secPhi_s);

		// "lrhls_data_tracksMHTHLS_data_qOverPt_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_qOverPt_s);

		// "lrhls_data_tracksMHTHLS_data_phi_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_phi_s);

		// "lrhls_data_tracksMHTHLS_data_z_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_z_s);

		// "lrhls_data_tracksMHTHLS_data_cot_s"
		char* tvin_lrhls_data_tracksMHTHLS_data_cot_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_cot_s);

		// "lrhls_data_tracksLRHLS_size_s"
		char* tvin_lrhls_data_tracksLRHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_size_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_size_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_size_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s);

		// "lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s"
		char* tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s);

		// "lrhls_data_tracksLRHLS_data_secEta_s"
		char* tvin_lrhls_data_tracksLRHLS_data_secEta_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secEta_s);

		// "lrhls_data_tracksLRHLS_data_secPhi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_secPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secPhi_s);

		// "lrhls_data_tracksLRHLS_data_qOverPt_s"
		char* tvin_lrhls_data_tracksLRHLS_data_qOverPt_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_qOverPt_s);

		// "lrhls_data_tracksLRHLS_data_phi_s"
		char* tvin_lrhls_data_tracksLRHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_phi_s);

		// "lrhls_data_tracksLRHLS_data_z_s"
		char* tvin_lrhls_data_tracksLRHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_z_s);

		// "lrhls_data_tracksLRHLS_data_cot_s"
		char* tvin_lrhls_data_tracksLRHLS_data_cot_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_cot_s);

		// "lrhls_numLayers_s"
		char* tvin_lrhls_numLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_numLayers_s);

		// "lrhls_minLayers_s"
		char* tvin_lrhls_minLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_minLayers_s);

		// "lrhls_minLayersPS_s"
		char* tvin_lrhls_minLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_minLayersPS_s);

		// "lrhls_residPhi_s"
		char* tvin_lrhls_residPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residPhi_s);

		// "lrhls_residZ2S_s"
		char* tvin_lrhls_residZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residZ2S_s);

		// "lrhls_residZPS_s"
		char* tvin_lrhls_residZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residZPS_s);

		// "lrhls_maxIteartions_s"
		char* tvin_lrhls_maxIteartions_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_maxIteartions_s);

		// "lrhls_track_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_track_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_track_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrNumIterations_s);

		// "lrhls_track_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_track_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_track_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayers_s);

		// "lrhls_track_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_track_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_track_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayersPS_s);

		// "lrhls_track_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_track_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_track_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidPhi_s);

		// "lrhls_track_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_track_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_track_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZ2S_s);

		// "lrhls_track_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_track_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_track_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZPS_s);

		// "lrhls_track_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_track_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_track_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofPhi_s);

		// "lrhls_track_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_track_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_track_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofZ_s);

		// "lrhls_track_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_track_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_track_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_invPtToDphi_s);

		// "lrhls_track_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_track_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_track_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_settingsHLS_trackerNumLayers_s);

		// "lrhls_track_stubsHLS_size_s"
		char* tvin_lrhls_track_stubsHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_size_s);
		char* tvout_lrhls_track_stubsHLS_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_size_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// "lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_barrel_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_psModule_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);

		// "lrhls_track_stubsHLS_data_moduleHLS_layerId_s"
		char* tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);
		char* tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);

		// "lrhls_track_stubsHLS_data_r_s"
		char* tvin_lrhls_track_stubsHLS_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_r_s);
		char* tvout_lrhls_track_stubsHLS_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_r_s);

		// "lrhls_track_stubsHLS_data_phi_s"
		char* tvin_lrhls_track_stubsHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_phi_s);
		char* tvout_lrhls_track_stubsHLS_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_phi_s);

		// "lrhls_track_stubsHLS_data_z_s"
		char* tvin_lrhls_track_stubsHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_stubsHLS_data_z_s);
		char* tvout_lrhls_track_stubsHLS_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_z_s);

		// "lrhls_track_secEta_s"
		char* tvin_lrhls_track_secEta_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_secEta_s);
		char* tvout_lrhls_track_secEta_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_secEta_s);

		// "lrhls_track_secPhi_s"
		char* tvin_lrhls_track_secPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_secPhi_s);
		char* tvout_lrhls_track_secPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_secPhi_s);

		// "lrhls_track_qOverPt_s"
		char* tvin_lrhls_track_qOverPt_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_qOverPt_s);
		char* tvout_lrhls_track_qOverPt_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_qOverPt_s);

		// "lrhls_track_phi_s"
		char* tvin_lrhls_track_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_phi_s);
		char* tvout_lrhls_track_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_phi_s);

		// "lrhls_track_z_s"
		char* tvin_lrhls_track_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_z_s);
		char* tvout_lrhls_track_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_z_s);

		// "lrhls_track_cot_s"
		char* tvin_lrhls_track_cot_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_track_cot_s);
		char* tvout_lrhls_track_cot_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_track_cot_s);

		// "lrhls_secPhi_s"
		char* tvout_lrhls_secPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_secPhi_s);

		// "lrhls_secEta_s"
		char* tvout_lrhls_secEta_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_secEta_s);

		// "lrhls_HTParameter_qOverPt"
		char* tvin_lrhls_HTParameter_qOverPt = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_HTParameter_qOverPt);
		char* tvout_lrhls_HTParameter_qOverPt = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_HTParameter_qOverPt);

		// "lrhls_HTParameter_phiT"
		char* tvin_lrhls_HTParameter_phiT = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_HTParameter_phiT);
		char* tvout_lrhls_HTParameter_phiT = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_HTParameter_phiT);

		// "lrhls_HTParameter_cotTheta"
		char* tvin_lrhls_HTParameter_cotTheta = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_HTParameter_cotTheta);
		char* tvout_lrhls_HTParameter_cotTheta = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_HTParameter_cotTheta);

		// "lrhls_HTParameter_zT"
		char* tvin_lrhls_HTParameter_zT = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_HTParameter_zT);
		char* tvout_lrhls_HTParameter_zT = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_HTParameter_zT);

		// "lrhls_LRParameter_qOverPt"
		char* tvin_lrhls_LRParameter_qOverPt = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_LRParameter_qOverPt);
		char* tvout_lrhls_LRParameter_qOverPt = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_LRParameter_qOverPt);

		// "lrhls_LRParameter_phiT"
		char* tvin_lrhls_LRParameter_phiT = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_LRParameter_phiT);
		char* tvout_lrhls_LRParameter_phiT = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_LRParameter_phiT);

		// "lrhls_LRParameter_cotTheta"
		char* tvin_lrhls_LRParameter_cotTheta = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_LRParameter_cotTheta);
		char* tvout_lrhls_LRParameter_cotTheta = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_LRParameter_cotTheta);

		// "lrhls_LRParameter_zT"
		char* tvin_lrhls_LRParameter_zT = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_LRParameter_zT);
		char* tvout_lrhls_LRParameter_zT = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_LRParameter_zT);

		// "lrhls_stubs_size_s"
		char* tvin_lrhls_stubs_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_size_s);
		char* tvout_lrhls_stubs_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_size_s);

		// "lrhls_stubs_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrNumIterations_s);

		// "lrhls_stubs_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayers_s);

		// "lrhls_stubs_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_stubs_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidPhi_s);

		// "lrhls_stubs_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_stubs_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZPS_s);

		// "lrhls_stubs_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_stubs_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofZ_s);

		// "lrhls_stubs_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_invPtToDphi_s);

		// "lrhls_stubs_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// "lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// "lrhls_stubs_data_moduleHLS_barrel_s"
		char* tvin_lrhls_stubs_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_barrel_s);
		char* tvout_lrhls_stubs_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_barrel_s);

		// "lrhls_stubs_data_moduleHLS_psModule_s"
		char* tvin_lrhls_stubs_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_psModule_s);
		char* tvout_lrhls_stubs_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_psModule_s);

		// "lrhls_stubs_data_moduleHLS_layerId_s"
		char* tvin_lrhls_stubs_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_layerId_s);
		char* tvout_lrhls_stubs_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_layerId_s);

		// "lrhls_stubs_data_r_s"
		char* tvin_lrhls_stubs_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_r_s);
		char* tvout_lrhls_stubs_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_r_s);

		// "lrhls_stubs_data_phi_s"
		char* tvin_lrhls_stubs_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_phi_s);
		char* tvout_lrhls_stubs_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_phi_s);

		// "lrhls_stubs_data_z_s"
		char* tvin_lrhls_stubs_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubs_data_z_s);
		char* tvout_lrhls_stubs_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubs_data_z_s);

		// "lrhls_valid_s"
		char* tvin_lrhls_valid_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_valid_s);
		char* tvout_lrhls_valid_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_valid_s);

		// "lrhls_stubMap_size_s"
		char* tvin_lrhls_stubMap_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_size_s);
		char* tvout_lrhls_stubMap_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_size_s);

		// "lrhls_stubMap_data_first"
		char* tvin_lrhls_stubMap_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_first);
		char* tvout_lrhls_stubMap_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_first);

		// "lrhls_stubMap_data_second_size_s"
		char* tvin_lrhls_stubMap_data_second_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_size_s);
		char* tvout_lrhls_stubMap_data_second_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_size_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);

		// "lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_barrel_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_psModule_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);

		// "lrhls_stubMap_data_second_data_moduleHLS_layerId_s"
		char* tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);
		char* tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);

		// "lrhls_stubMap_data_second_data_r_s"
		char* tvin_lrhls_stubMap_data_second_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_r_s);
		char* tvout_lrhls_stubMap_data_second_data_r_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_r_s);

		// "lrhls_stubMap_data_second_data_phi_s"
		char* tvin_lrhls_stubMap_data_second_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_phi_s);
		char* tvout_lrhls_stubMap_data_second_data_phi_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_phi_s);

		// "lrhls_stubMap_data_second_data_z_s"
		char* tvin_lrhls_stubMap_data_second_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_stubMap_data_second_data_z_s);
		char* tvout_lrhls_stubMap_data_second_data_z_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_z_s);

		// "lrhls_layerPopulation_size_s"
		char* tvin_lrhls_layerPopulation_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_layerPopulation_size_s);
		char* tvout_lrhls_layerPopulation_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_layerPopulation_size_s);

		// "lrhls_layerPopulation_data_first"
		char* tvin_lrhls_layerPopulation_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_layerPopulation_data_first);
		char* tvout_lrhls_layerPopulation_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_layerPopulation_data_first);

		// "lrhls_layerPopulation_data_second"
		char* tvin_lrhls_layerPopulation_data_second = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_layerPopulation_data_second);
		char* tvout_lrhls_layerPopulation_data_second = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_layerPopulation_data_second);

		// "lrhls_residuals_size_s"
		char* tvout_lrhls_residuals_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_size_s);

		// "lrhls_residuals_data_first"
		char* tvin_lrhls_residuals_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_first);
		char* tvout_lrhls_residuals_data_first = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_first);

		// "lrhls_residuals_data_second_size_s"
		char* tvin_lrhls_residuals_data_second_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_size_s);
		char* tvout_lrhls_residuals_data_second_size_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_size_s);

		// "lrhls_residuals_data_second_data_phi"
		char* tvin_lrhls_residuals_data_second_data_phi = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_data_phi);
		char* tvout_lrhls_residuals_data_second_data_phi = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_data_phi);

		// "lrhls_residuals_data_second_data_z"
		char* tvin_lrhls_residuals_data_second_data_z = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_data_z);
		char* tvout_lrhls_residuals_data_second_data_z = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_data_z);

		// "lrhls_residuals_data_second_data_layerId"
		char* tvin_lrhls_residuals_data_second_data_layerId = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_data_layerId);
		char* tvout_lrhls_residuals_data_second_data_layerId = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_data_layerId);

		// "lrhls_residuals_data_second_data_stubId"
		char* tvin_lrhls_residuals_data_second_data_stubId = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_data_stubId);
		char* tvout_lrhls_residuals_data_second_data_stubId = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_data_stubId);

		// "lrhls_residuals_data_second_data_ps"
		char* tvin_lrhls_residuals_data_second_data_ps = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_residuals_data_second_data_ps);
		char* tvout_lrhls_residuals_data_second_data_ps = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_residuals_data_second_data_ps);

		// "lrhls_largestResid_phi"
		char* tvout_lrhls_largestResid_phi = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_largestResid_phi);

		// "lrhls_largestResid_z"
		char* tvout_lrhls_largestResid_z = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_largestResid_z);

		// "lrhls_largestResid_layerId"
		char* tvout_lrhls_largestResid_layerId = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_largestResid_layerId);

		// "lrhls_largestResid_stubId"
		char* tvout_lrhls_largestResid_stubId = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_largestResid_stubId);

		// "lrhls_largestResid_ps"
		char* tvout_lrhls_largestResid_ps = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_largestResid_ps);

		// "lrhls_nIterations_s"
		char* tvin_lrhls_nIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lrhls_nIterations_s);
		char* tvout_lrhls_nIterations_s = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_lrhls_nIterations_s);

		CodeState = DUMP_INPUTS;
		static INTER_TCL_FILE tcl_file(INTER_TCL);
		int leading_zero;

		// [[transaction]]
		sprintf(tvin_lrhls_settings_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofPhi_s, tvin_lrhls_settings_chosenRofPhi_s);

		sc_bv<32>* lrhls_settings_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_settings_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.settings_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.settings_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.settings_.chosenRofPhi_
						// regulate_c_name       : lrhls_settings__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.settings_.chosenRofPhi_
						if (&(lrhls.settings_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_settings__chosenRofPhi__tmp_mem;
							lrhls_settings__chosenRofPhi__tmp_mem = *(int*)&lrhls.settings_.chosenRofPhi_;
							lrhls_settings_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_settings__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_settings_chosenRofPhi_s, "%s\n", (lrhls_settings_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofPhi_s, tvin_lrhls_settings_chosenRofPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_settings_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_settings_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofPhi_s, tvin_lrhls_settings_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_settings_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_settings_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofZ_s, tvin_lrhls_settings_chosenRofZ_s);

		sc_bv<32>* lrhls_settings_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_settings_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.settings_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.settings_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.settings_.chosenRofZ_
						// regulate_c_name       : lrhls_settings__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.settings_.chosenRofZ_
						if (&(lrhls.settings_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_settings__chosenRofZ__tmp_mem;
							lrhls_settings__chosenRofZ__tmp_mem = *(int*)&lrhls.settings_.chosenRofZ_;
							lrhls_settings_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_settings__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_settings_chosenRofZ_s, "%s\n", (lrhls_settings_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofZ_s, tvin_lrhls_settings_chosenRofZ_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_settings_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_settings_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_chosenRofZ_s, tvin_lrhls_settings_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_settings_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_settings_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_invPtToDphi_s, tvin_lrhls_settings_invPtToDphi_s);

		sc_bv<32>* lrhls_settings_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_settings_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.settings_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.settings_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.settings_.invPtToDphi_
						// regulate_c_name       : lrhls_settings__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.settings_.invPtToDphi_
						if (&(lrhls.settings_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_settings__invPtToDphi__tmp_mem;
							lrhls_settings__invPtToDphi__tmp_mem = *(int*)&lrhls.settings_.invPtToDphi_;
							lrhls_settings_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_settings__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_settings_invPtToDphi_s, "%s\n", (lrhls_settings_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_settings_invPtToDphi_s, tvin_lrhls_settings_invPtToDphi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_settings_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_settings_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_settings_invPtToDphi_s, tvin_lrhls_settings_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_settings_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_size_s, tvin_lrhls_data_tracksMHTHLS_size_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_data_tracksMHTHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.size_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__size_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.size_
						if (&(lrhls.data_.tracksMHTHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__size__tmp_mem;
							lrhls_data__tracksMHTHLS__size__tmp_mem = lrhls.data_.tracksMHTHLS_.size_;
							lrhls_data_tracksMHTHLS_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_size_s, "%s\n", (lrhls_data_tracksMHTHLS_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_size_s, tvin_lrhls_data_tracksMHTHLS_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_data_tracksMHTHLS_size_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_size_s, tvin_lrhls_data_tracksMHTHLS_size_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_data__tracksMHTHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.size_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.size_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__size_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.size_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__size__tmp_mem;
							lrhls_data__tracksMHTHLS__data__stubsHLS__size__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.size_;
							lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer = new sc_bv<1>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.barrel_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__barrel_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer = new sc_bv<1>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.psModule_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__psModule_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.layerId_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__layerId_
							// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].r_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].r_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__r_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].r_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__r__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__r__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].r_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__r__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].phi_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__phi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__phi__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__phi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__phi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.stubsHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].z_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].z_
							// regulate_c_name       : lrhls_data__tracksMHTHLS__data__stubsHLS__data__z_
							// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].z_
							if (&(lrhls.data_.tracksMHTHLS_.data_[0].stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksMHTHLS__data__stubsHLS__data__z__tmp_mem;
								lrhls_data__tracksMHTHLS__data__stubsHLS__data__z__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].stubsHLS_.data_[i_1].z_;
								lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__stubsHLS__data__z__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, "%s\n", (lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_secEta_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secEta_s, tvin_lrhls_data_tracksMHTHLS_data_secEta_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_secEta_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_secEta_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.secEta_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].secEta_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].secEta_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__secEta_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].secEta_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].secEta_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__secEta__tmp_mem;
							lrhls_data__tracksMHTHLS__data__secEta__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].secEta_;
							lrhls_data_tracksMHTHLS_data_secEta_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__secEta__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_secEta_s, "%s\n", (lrhls_data_tracksMHTHLS_data_secEta_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secEta_s, tvin_lrhls_data_tracksMHTHLS_data_secEta_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_secEta_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_secEta_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secEta_s, tvin_lrhls_data_tracksMHTHLS_data_secEta_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_secEta_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_secPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secPhi_s, tvin_lrhls_data_tracksMHTHLS_data_secPhi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_secPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_secPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.secPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].secPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].secPhi_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__secPhi_
						// input_type_conversion : lrhls.data_.tracksMHTHLS_.data_[i_0].secPhi_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].secPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__secPhi__tmp_mem;
							lrhls_data__tracksMHTHLS__data__secPhi__tmp_mem = lrhls.data_.tracksMHTHLS_.data_[i_0].secPhi_;
							lrhls_data_tracksMHTHLS_data_secPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__secPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_secPhi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_secPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secPhi_s, tvin_lrhls_data_tracksMHTHLS_data_secPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_secPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_secPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_secPhi_s, tvin_lrhls_data_tracksMHTHLS_data_secPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_secPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_qOverPt_s, tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_qOverPt_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_qOverPt_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.qOverPt_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].qOverPt_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].qOverPt_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__qOverPt_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].qOverPt_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].qOverPt_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__qOverPt__tmp_mem;
							lrhls_data__tracksMHTHLS__data__qOverPt__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].qOverPt_;
							lrhls_data_tracksMHTHLS_data_qOverPt_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__qOverPt__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s, "%s\n", (lrhls_data_tracksMHTHLS_data_qOverPt_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_qOverPt_s, tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_qOverPt_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_qOverPt_s, tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_qOverPt_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_phi_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].phi_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__phi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].phi_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__phi__tmp_mem;
							lrhls_data__tracksMHTHLS__data__phi__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].phi_;
							lrhls_data_tracksMHTHLS_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_phi_s, "%s\n", (lrhls_data_tracksMHTHLS_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_phi_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_phi_s, tvin_lrhls_data_tracksMHTHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_z_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].z_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__z_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].z_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__z__tmp_mem;
							lrhls_data__tracksMHTHLS__data__z__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].z_;
							lrhls_data_tracksMHTHLS_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_z_s, "%s\n", (lrhls_data_tracksMHTHLS_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_z_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_z_s, tvin_lrhls_data_tracksMHTHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_cot_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_cot_s, tvin_lrhls_data_tracksMHTHLS_data_cot_s);

		sc_bv<32>* lrhls_data_tracksMHTHLS_data_cot_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksMHTHLS_data_cot_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksMHTHLS_.data_.cot_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksMHTHLS_.data_[i_0].cot_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksMHTHLS_.data_[0].cot_
						// regulate_c_name       : lrhls_data__tracksMHTHLS__data__cot_
						// input_type_conversion : *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].cot_
						if (&(lrhls.data_.tracksMHTHLS_.data_[0].cot_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksMHTHLS__data__cot__tmp_mem;
							lrhls_data__tracksMHTHLS__data__cot__tmp_mem = *(int*)&lrhls.data_.tracksMHTHLS_.data_[i_0].cot_;
							lrhls_data_tracksMHTHLS_data_cot_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksMHTHLS__data__cot__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksMHTHLS_data_cot_s, "%s\n", (lrhls_data_tracksMHTHLS_data_cot_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_cot_s, tvin_lrhls_data_tracksMHTHLS_data_cot_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksMHTHLS_data_cot_s_depth);
		sprintf(tvin_lrhls_data_tracksMHTHLS_data_cot_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksMHTHLS_data_cot_s, tvin_lrhls_data_tracksMHTHLS_data_cot_s);

		// release memory allocation
		delete [] lrhls_data_tracksMHTHLS_data_cot_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_size_s, tvin_lrhls_data_tracksLRHLS_size_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_data_tracksLRHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.size_
						// regulate_c_name       : lrhls_data__tracksLRHLS__size_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.size_
						if (&(lrhls.data_.tracksLRHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__size__tmp_mem;
							lrhls_data__tracksLRHLS__size__tmp_mem = lrhls.data_.tracksLRHLS_.size_;
							lrhls_data_tracksLRHLS_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_size_s, "%s\n", (lrhls_data_tracksLRHLS_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_size_s, tvin_lrhls_data_tracksLRHLS_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_data_tracksLRHLS_size_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_size_s, tvin_lrhls_data_tracksLRHLS_size_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_data__tracksLRHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_size_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.size_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.size_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__size_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.size_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__size__tmp_mem;
							lrhls_data__tracksLRHLS__data__stubsHLS__size__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.size_;
							lrhls_data_tracksLRHLS_data_stubsHLS_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_size_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_size_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrNumIterations_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayers_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrMinLayersPS_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidPhi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZ2S_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.lrResidZPS_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofPhi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.chosenRofZ_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.invPtToDphi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].settingsHLS_.trackerNumLayers_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer = new sc_bv<1>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.barrel_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__barrel_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.barrel_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer = new sc_bv<1>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.psModule_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__psModule_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.psModule_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.layerId_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__layerId_
							// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].moduleHLS_.layerId_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].r_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].r_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__r_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].r_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__r__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__r__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].r_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__r__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].phi_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__phi_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__phi__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__phi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].phi_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__phi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[256];

		// RTL Name: lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.stubsHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].z_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].z_
							// regulate_c_name       : lrhls_data__tracksLRHLS__data__stubsHLS__data__z_
							// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].z_
							if (&(lrhls.data_.tracksLRHLS_.data_[0].stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_data__tracksLRHLS__data__stubsHLS__data__z__tmp_mem;
								lrhls_data__tracksLRHLS__data__stubsHLS__data__z__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].stubsHLS_.data_[i_1].z_;
								lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__stubsHLS__data__z__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 256; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, "%s\n", (lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s);
		}

		tcl_file.set_num(256, &tcl_file.lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_secEta_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secEta_s, tvin_lrhls_data_tracksLRHLS_data_secEta_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_secEta_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_secEta_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.secEta_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].secEta_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].secEta_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__secEta_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].secEta_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].secEta_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__secEta__tmp_mem;
							lrhls_data__tracksLRHLS__data__secEta__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].secEta_;
							lrhls_data_tracksLRHLS_data_secEta_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__secEta__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_secEta_s, "%s\n", (lrhls_data_tracksLRHLS_data_secEta_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secEta_s, tvin_lrhls_data_tracksLRHLS_data_secEta_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_secEta_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_secEta_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secEta_s, tvin_lrhls_data_tracksLRHLS_data_secEta_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_secEta_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_secPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secPhi_s, tvin_lrhls_data_tracksLRHLS_data_secPhi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_secPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_secPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.secPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].secPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].secPhi_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__secPhi_
						// input_type_conversion : lrhls.data_.tracksLRHLS_.data_[i_0].secPhi_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].secPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__secPhi__tmp_mem;
							lrhls_data__tracksLRHLS__data__secPhi__tmp_mem = lrhls.data_.tracksLRHLS_.data_[i_0].secPhi_;
							lrhls_data_tracksLRHLS_data_secPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__secPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_secPhi_s, "%s\n", (lrhls_data_tracksLRHLS_data_secPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secPhi_s, tvin_lrhls_data_tracksLRHLS_data_secPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_secPhi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_secPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_secPhi_s, tvin_lrhls_data_tracksLRHLS_data_secPhi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_secPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_qOverPt_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_qOverPt_s, tvin_lrhls_data_tracksLRHLS_data_qOverPt_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_qOverPt_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_qOverPt_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.qOverPt_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].qOverPt_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].qOverPt_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__qOverPt_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].qOverPt_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].qOverPt_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__qOverPt__tmp_mem;
							lrhls_data__tracksLRHLS__data__qOverPt__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].qOverPt_;
							lrhls_data_tracksLRHLS_data_qOverPt_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__qOverPt__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_qOverPt_s, "%s\n", (lrhls_data_tracksLRHLS_data_qOverPt_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_qOverPt_s, tvin_lrhls_data_tracksLRHLS_data_qOverPt_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_qOverPt_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_qOverPt_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_qOverPt_s, tvin_lrhls_data_tracksLRHLS_data_qOverPt_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_qOverPt_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_phi_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].phi_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__phi_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].phi_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__phi__tmp_mem;
							lrhls_data__tracksLRHLS__data__phi__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].phi_;
							lrhls_data_tracksLRHLS_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_phi_s, "%s\n", (lrhls_data_tracksLRHLS_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_phi_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_phi_s, tvin_lrhls_data_tracksLRHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_z_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].z_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__z_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].z_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__z__tmp_mem;
							lrhls_data__tracksLRHLS__data__z__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].z_;
							lrhls_data_tracksLRHLS_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_z_s, "%s\n", (lrhls_data_tracksLRHLS_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_z_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_z_s, tvin_lrhls_data_tracksLRHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_data_tracksLRHLS_data_cot_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_cot_s, tvin_lrhls_data_tracksLRHLS_data_cot_s);

		sc_bv<32>* lrhls_data_tracksLRHLS_data_cot_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_data_tracksLRHLS_data_cot_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.data_.tracksLRHLS_.data_.cot_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.data_.tracksLRHLS_.data_[i_0].cot_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.data_.tracksLRHLS_.data_[0].cot_
						// regulate_c_name       : lrhls_data__tracksLRHLS__data__cot_
						// input_type_conversion : *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].cot_
						if (&(lrhls.data_.tracksLRHLS_.data_[0].cot_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_data__tracksLRHLS__data__cot__tmp_mem;
							lrhls_data__tracksLRHLS__data__cot__tmp_mem = *(int*)&lrhls.data_.tracksLRHLS_.data_[i_0].cot_;
							lrhls_data_tracksLRHLS_data_cot_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_data__tracksLRHLS__data__cot__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_data_tracksLRHLS_data_cot_s, "%s\n", (lrhls_data_tracksLRHLS_data_cot_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_cot_s, tvin_lrhls_data_tracksLRHLS_data_cot_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_data_tracksLRHLS_data_cot_s_depth);
		sprintf(tvin_lrhls_data_tracksLRHLS_data_cot_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_data_tracksLRHLS_data_cot_s, tvin_lrhls_data_tracksLRHLS_data_cot_s);

		// release memory allocation
		delete [] lrhls_data_tracksLRHLS_data_cot_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_numLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_numLayers_s, tvin_lrhls_numLayers_s);

		sc_bv<32>* lrhls_numLayers_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_numLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.numLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.numLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.numLayers_
						// regulate_c_name       : lrhls_numLayers_
						// input_type_conversion : lrhls.numLayers_
						if (&(lrhls.numLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_numLayers__tmp_mem;
							lrhls_numLayers__tmp_mem = lrhls.numLayers_;
							lrhls_numLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_numLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_numLayers_s, "%s\n", (lrhls_numLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_numLayers_s, tvin_lrhls_numLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_numLayers_s_depth);
		sprintf(tvin_lrhls_numLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_numLayers_s, tvin_lrhls_numLayers_s);

		// release memory allocation
		delete [] lrhls_numLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_minLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_minLayers_s, tvin_lrhls_minLayers_s);

		sc_bv<32>* lrhls_minLayers_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_minLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.minLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.minLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.minLayers_
						// regulate_c_name       : lrhls_minLayers_
						// input_type_conversion : lrhls.minLayers_
						if (&(lrhls.minLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_minLayers__tmp_mem;
							lrhls_minLayers__tmp_mem = lrhls.minLayers_;
							lrhls_minLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_minLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_minLayers_s, "%s\n", (lrhls_minLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_minLayers_s, tvin_lrhls_minLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_minLayers_s_depth);
		sprintf(tvin_lrhls_minLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_minLayers_s, tvin_lrhls_minLayers_s);

		// release memory allocation
		delete [] lrhls_minLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_minLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_minLayersPS_s, tvin_lrhls_minLayersPS_s);

		sc_bv<32>* lrhls_minLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_minLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.minLayersPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.minLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.minLayersPS_
						// regulate_c_name       : lrhls_minLayersPS_
						// input_type_conversion : lrhls.minLayersPS_
						if (&(lrhls.minLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_minLayersPS__tmp_mem;
							lrhls_minLayersPS__tmp_mem = lrhls.minLayersPS_;
							lrhls_minLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_minLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_minLayersPS_s, "%s\n", (lrhls_minLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_minLayersPS_s, tvin_lrhls_minLayersPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_minLayersPS_s_depth);
		sprintf(tvin_lrhls_minLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_minLayersPS_s, tvin_lrhls_minLayersPS_s);

		// release memory allocation
		delete [] lrhls_minLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residPhi_s, tvin_lrhls_residPhi_s);

		sc_bv<32>* lrhls_residPhi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_residPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residPhi_
						// regulate_c_name       : lrhls_residPhi_
						// input_type_conversion : *(int*)&lrhls.residPhi_
						if (&(lrhls.residPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residPhi__tmp_mem;
							lrhls_residPhi__tmp_mem = *(int*)&lrhls.residPhi_;
							lrhls_residPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_residPhi_s, "%s\n", (lrhls_residPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residPhi_s, tvin_lrhls_residPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_residPhi_s_depth);
		sprintf(tvin_lrhls_residPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residPhi_s, tvin_lrhls_residPhi_s);

		// release memory allocation
		delete [] lrhls_residPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residZ2S_s, tvin_lrhls_residZ2S_s);

		sc_bv<32>* lrhls_residZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_residZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residZ2S_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residZ2S_
						// regulate_c_name       : lrhls_residZ2S_
						// input_type_conversion : *(int*)&lrhls.residZ2S_
						if (&(lrhls.residZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residZ2S__tmp_mem;
							lrhls_residZ2S__tmp_mem = *(int*)&lrhls.residZ2S_;
							lrhls_residZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_residZ2S_s, "%s\n", (lrhls_residZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residZ2S_s, tvin_lrhls_residZ2S_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_residZ2S_s_depth);
		sprintf(tvin_lrhls_residZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residZ2S_s, tvin_lrhls_residZ2S_s);

		// release memory allocation
		delete [] lrhls_residZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residZPS_s, tvin_lrhls_residZPS_s);

		sc_bv<32>* lrhls_residZPS_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_residZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residZPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residZPS_
						// regulate_c_name       : lrhls_residZPS_
						// input_type_conversion : *(int*)&lrhls.residZPS_
						if (&(lrhls.residZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residZPS__tmp_mem;
							lrhls_residZPS__tmp_mem = *(int*)&lrhls.residZPS_;
							lrhls_residZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_residZPS_s, "%s\n", (lrhls_residZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residZPS_s, tvin_lrhls_residZPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_residZPS_s_depth);
		sprintf(tvin_lrhls_residZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residZPS_s, tvin_lrhls_residZPS_s);

		// release memory allocation
		delete [] lrhls_residZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_maxIteartions_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_maxIteartions_s, tvin_lrhls_maxIteartions_s);

		sc_bv<32>* lrhls_maxIteartions_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_maxIteartions_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.maxIteartions_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.maxIteartions_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.maxIteartions_
						// regulate_c_name       : lrhls_maxIteartions_
						// input_type_conversion : lrhls.maxIteartions_
						if (&(lrhls.maxIteartions_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_maxIteartions__tmp_mem;
							lrhls_maxIteartions__tmp_mem = lrhls.maxIteartions_;
							lrhls_maxIteartions_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_maxIteartions__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_maxIteartions_s, "%s\n", (lrhls_maxIteartions_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_maxIteartions_s, tvin_lrhls_maxIteartions_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_maxIteartions_s_depth);
		sprintf(tvin_lrhls_maxIteartions_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_maxIteartions_s, tvin_lrhls_maxIteartions_s);

		// release memory allocation
		delete [] lrhls_maxIteartions_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrNumIterations_s, tvin_lrhls_track_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.settingsHLS_.lrNumIterations_;
							lrhls_track_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrNumIterations_s, tvin_lrhls_track_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrNumIterations_s, tvin_lrhls_track_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayers_s, tvin_lrhls_track_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.settingsHLS_.lrMinLayers_;
							lrhls_track_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayers_s, tvin_lrhls_track_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayers_s, tvin_lrhls_track_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.settingsHLS_.lrMinLayersPS_;
							lrhls_track_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidPhi_s, tvin_lrhls_track_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidPhi_;
							lrhls_track_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidPhi_s, tvin_lrhls_track_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidPhi_s, tvin_lrhls_track_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_;
							lrhls_track_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZPS_s, tvin_lrhls_track_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidZPS_;
							lrhls_track_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZPS_s, tvin_lrhls_track_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_lrResidZPS_s, tvin_lrhls_track_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_;
							lrhls_track_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofZ_s, tvin_lrhls_track_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.chosenRofZ_;
							lrhls_track_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofZ_s, tvin_lrhls_track_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_chosenRofZ_s, tvin_lrhls_track_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_invPtToDphi_s, tvin_lrhls_track_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.invPtToDphi_;
							lrhls_track_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_invPtToDphi_s, tvin_lrhls_track_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_invPtToDphi_s, tvin_lrhls_track_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.settingsHLS_.trackerNumLayers_;
							lrhls_track_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_track_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_size_s, tvin_lrhls_track_stubsHLS_size_s);

		sc_bv<32>* lrhls_track_stubsHLS_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_stubsHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.size_
						// regulate_c_name       : lrhls_track__stubsHLS__size_
						// input_type_conversion : lrhls.track_.stubsHLS_.size_
						if (&(lrhls.track_.stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__size__tmp_mem;
							lrhls_track__stubsHLS__size__tmp_mem = lrhls.track_.stubsHLS_.size_;
							lrhls_track_stubsHLS_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_size_s, "%s\n", (lrhls_track_stubsHLS_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_size_s, tvin_lrhls_track_stubsHLS_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_stubsHLS_size_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_size_s, tvin_lrhls_track_stubsHLS_size_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__barrel_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_;
							lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_barrel_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__psModule_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_;
							lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_psModule_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__layerId_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_;
							lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_layerId_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_r_s, tvin_lrhls_track_stubsHLS_data_r_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_r_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].r_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].r_
						// regulate_c_name       : lrhls_track__stubsHLS__data__r_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_
						if (&(lrhls.track_.stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__r__tmp_mem;
							lrhls_track__stubsHLS__data__r__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_;
							lrhls_track_stubsHLS_data_r_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__r__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_r_s, "%s\n", (lrhls_track_stubsHLS_data_r_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_r_s, tvin_lrhls_track_stubsHLS_data_r_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_r_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_r_s, tvin_lrhls_track_stubsHLS_data_r_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_r_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_phi_s, tvin_lrhls_track_stubsHLS_data_phi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].phi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__phi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_
						if (&(lrhls.track_.stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__phi__tmp_mem;
							lrhls_track__stubsHLS__data__phi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_;
							lrhls_track_stubsHLS_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_phi_s, "%s\n", (lrhls_track_stubsHLS_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_phi_s, tvin_lrhls_track_stubsHLS_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_phi_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_phi_s, tvin_lrhls_track_stubsHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_stubsHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_z_s, tvin_lrhls_track_stubsHLS_data_z_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].z_
						// regulate_c_name       : lrhls_track__stubsHLS__data__z_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_
						if (&(lrhls.track_.stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__z__tmp_mem;
							lrhls_track__stubsHLS__data__z__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_;
							lrhls_track_stubsHLS_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_track_stubsHLS_data_z_s, "%s\n", (lrhls_track_stubsHLS_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_z_s, tvin_lrhls_track_stubsHLS_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_z_s_depth);
		sprintf(tvin_lrhls_track_stubsHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_stubsHLS_data_z_s, tvin_lrhls_track_stubsHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_secEta_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_secEta_s, tvin_lrhls_track_secEta_s);

		sc_bv<32>* lrhls_track_secEta_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_secEta_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.secEta_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.secEta_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.secEta_
						// regulate_c_name       : lrhls_track__secEta_
						// input_type_conversion : lrhls.track_.secEta_
						if (&(lrhls.track_.secEta_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__secEta__tmp_mem;
							lrhls_track__secEta__tmp_mem = lrhls.track_.secEta_;
							lrhls_track_secEta_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__secEta__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_secEta_s, "%s\n", (lrhls_track_secEta_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_secEta_s, tvin_lrhls_track_secEta_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_secEta_s_depth);
		sprintf(tvin_lrhls_track_secEta_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_secEta_s, tvin_lrhls_track_secEta_s);

		// release memory allocation
		delete [] lrhls_track_secEta_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_secPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_secPhi_s, tvin_lrhls_track_secPhi_s);

		sc_bv<32>* lrhls_track_secPhi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_secPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.secPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.secPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.secPhi_
						// regulate_c_name       : lrhls_track__secPhi_
						// input_type_conversion : lrhls.track_.secPhi_
						if (&(lrhls.track_.secPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__secPhi__tmp_mem;
							lrhls_track__secPhi__tmp_mem = lrhls.track_.secPhi_;
							lrhls_track_secPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__secPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_secPhi_s, "%s\n", (lrhls_track_secPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_secPhi_s, tvin_lrhls_track_secPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_secPhi_s_depth);
		sprintf(tvin_lrhls_track_secPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_secPhi_s, tvin_lrhls_track_secPhi_s);

		// release memory allocation
		delete [] lrhls_track_secPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_qOverPt_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_qOverPt_s, tvin_lrhls_track_qOverPt_s);

		sc_bv<32>* lrhls_track_qOverPt_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_qOverPt_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.qOverPt_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.qOverPt_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.qOverPt_
						// regulate_c_name       : lrhls_track__qOverPt_
						// input_type_conversion : *(int*)&lrhls.track_.qOverPt_
						if (&(lrhls.track_.qOverPt_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__qOverPt__tmp_mem;
							lrhls_track__qOverPt__tmp_mem = *(int*)&lrhls.track_.qOverPt_;
							lrhls_track_qOverPt_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__qOverPt__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_qOverPt_s, "%s\n", (lrhls_track_qOverPt_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_qOverPt_s, tvin_lrhls_track_qOverPt_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_qOverPt_s_depth);
		sprintf(tvin_lrhls_track_qOverPt_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_qOverPt_s, tvin_lrhls_track_qOverPt_s);

		// release memory allocation
		delete [] lrhls_track_qOverPt_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_phi_s, tvin_lrhls_track_phi_s);

		sc_bv<32>* lrhls_track_phi_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.phi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.phi_
						// regulate_c_name       : lrhls_track__phi_
						// input_type_conversion : *(int*)&lrhls.track_.phi_
						if (&(lrhls.track_.phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__phi__tmp_mem;
							lrhls_track__phi__tmp_mem = *(int*)&lrhls.track_.phi_;
							lrhls_track_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_phi_s, "%s\n", (lrhls_track_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_phi_s, tvin_lrhls_track_phi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_phi_s_depth);
		sprintf(tvin_lrhls_track_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_phi_s, tvin_lrhls_track_phi_s);

		// release memory allocation
		delete [] lrhls_track_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_z_s, tvin_lrhls_track_z_s);

		sc_bv<32>* lrhls_track_z_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.z_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.z_
						// regulate_c_name       : lrhls_track__z_
						// input_type_conversion : *(int*)&lrhls.track_.z_
						if (&(lrhls.track_.z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__z__tmp_mem;
							lrhls_track__z__tmp_mem = *(int*)&lrhls.track_.z_;
							lrhls_track_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_z_s, "%s\n", (lrhls_track_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_z_s, tvin_lrhls_track_z_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_z_s_depth);
		sprintf(tvin_lrhls_track_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_z_s, tvin_lrhls_track_z_s);

		// release memory allocation
		delete [] lrhls_track_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_track_cot_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_cot_s, tvin_lrhls_track_cot_s);

		sc_bv<32>* lrhls_track_cot_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_cot_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.cot_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.cot_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.cot_
						// regulate_c_name       : lrhls_track__cot_
						// input_type_conversion : *(int*)&lrhls.track_.cot_
						if (&(lrhls.track_.cot_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__cot__tmp_mem;
							lrhls_track__cot__tmp_mem = *(int*)&lrhls.track_.cot_;
							lrhls_track_cot_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__cot__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_track_cot_s, "%s\n", (lrhls_track_cot_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_track_cot_s, tvin_lrhls_track_cot_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_cot_s_depth);
		sprintf(tvin_lrhls_track_cot_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_track_cot_s, tvin_lrhls_track_cot_s);

		// release memory allocation
		delete [] lrhls_track_cot_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_HTParameter_qOverPt, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_qOverPt, tvin_lrhls_HTParameter_qOverPt);

		sc_bv<32>* lrhls_HTParameter_qOverPt_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_qOverPt
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.qOverPt(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.qOverPt
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.qOverPt
						// regulate_c_name       : lrhls_HTParameter__qOverPt
						// input_type_conversion : *(int*)&lrhls.HTParameter_.qOverPt
						if (&(lrhls.HTParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__qOverPt_tmp_mem;
							lrhls_HTParameter__qOverPt_tmp_mem = *(int*)&lrhls.HTParameter_.qOverPt;
							lrhls_HTParameter_qOverPt_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__qOverPt_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_HTParameter_qOverPt, "%s\n", (lrhls_HTParameter_qOverPt_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_qOverPt, tvin_lrhls_HTParameter_qOverPt);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_qOverPt_depth);
		sprintf(tvin_lrhls_HTParameter_qOverPt, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_qOverPt, tvin_lrhls_HTParameter_qOverPt);

		// release memory allocation
		delete [] lrhls_HTParameter_qOverPt_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_HTParameter_phiT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_phiT, tvin_lrhls_HTParameter_phiT);

		sc_bv<32>* lrhls_HTParameter_phiT_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_phiT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.phiT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.phiT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.phiT
						// regulate_c_name       : lrhls_HTParameter__phiT
						// input_type_conversion : *(int*)&lrhls.HTParameter_.phiT
						if (&(lrhls.HTParameter_.phiT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__phiT_tmp_mem;
							lrhls_HTParameter__phiT_tmp_mem = *(int*)&lrhls.HTParameter_.phiT;
							lrhls_HTParameter_phiT_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__phiT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_HTParameter_phiT, "%s\n", (lrhls_HTParameter_phiT_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_phiT, tvin_lrhls_HTParameter_phiT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_phiT_depth);
		sprintf(tvin_lrhls_HTParameter_phiT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_phiT, tvin_lrhls_HTParameter_phiT);

		// release memory allocation
		delete [] lrhls_HTParameter_phiT_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_HTParameter_cotTheta, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_cotTheta, tvin_lrhls_HTParameter_cotTheta);

		sc_bv<32>* lrhls_HTParameter_cotTheta_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_cotTheta
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.cotTheta(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.cotTheta
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.cotTheta
						// regulate_c_name       : lrhls_HTParameter__cotTheta
						// input_type_conversion : *(int*)&lrhls.HTParameter_.cotTheta
						if (&(lrhls.HTParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__cotTheta_tmp_mem;
							lrhls_HTParameter__cotTheta_tmp_mem = *(int*)&lrhls.HTParameter_.cotTheta;
							lrhls_HTParameter_cotTheta_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__cotTheta_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_HTParameter_cotTheta, "%s\n", (lrhls_HTParameter_cotTheta_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_cotTheta, tvin_lrhls_HTParameter_cotTheta);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_cotTheta_depth);
		sprintf(tvin_lrhls_HTParameter_cotTheta, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_cotTheta, tvin_lrhls_HTParameter_cotTheta);

		// release memory allocation
		delete [] lrhls_HTParameter_cotTheta_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_HTParameter_zT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_zT, tvin_lrhls_HTParameter_zT);

		sc_bv<32>* lrhls_HTParameter_zT_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_zT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.zT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.zT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.zT
						// regulate_c_name       : lrhls_HTParameter__zT
						// input_type_conversion : *(int*)&lrhls.HTParameter_.zT
						if (&(lrhls.HTParameter_.zT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__zT_tmp_mem;
							lrhls_HTParameter__zT_tmp_mem = *(int*)&lrhls.HTParameter_.zT;
							lrhls_HTParameter_zT_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__zT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_HTParameter_zT, "%s\n", (lrhls_HTParameter_zT_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_zT, tvin_lrhls_HTParameter_zT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_zT_depth);
		sprintf(tvin_lrhls_HTParameter_zT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_HTParameter_zT, tvin_lrhls_HTParameter_zT);

		// release memory allocation
		delete [] lrhls_HTParameter_zT_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_LRParameter_qOverPt, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_qOverPt, tvin_lrhls_LRParameter_qOverPt);

		sc_bv<32>* lrhls_LRParameter_qOverPt_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_qOverPt
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.qOverPt(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.qOverPt
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.qOverPt
						// regulate_c_name       : lrhls_LRParameter__qOverPt
						// input_type_conversion : *(int*)&lrhls.LRParameter_.qOverPt
						if (&(lrhls.LRParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__qOverPt_tmp_mem;
							lrhls_LRParameter__qOverPt_tmp_mem = *(int*)&lrhls.LRParameter_.qOverPt;
							lrhls_LRParameter_qOverPt_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__qOverPt_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_LRParameter_qOverPt, "%s\n", (lrhls_LRParameter_qOverPt_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_qOverPt, tvin_lrhls_LRParameter_qOverPt);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_qOverPt_depth);
		sprintf(tvin_lrhls_LRParameter_qOverPt, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_qOverPt, tvin_lrhls_LRParameter_qOverPt);

		// release memory allocation
		delete [] lrhls_LRParameter_qOverPt_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_LRParameter_phiT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_phiT, tvin_lrhls_LRParameter_phiT);

		sc_bv<32>* lrhls_LRParameter_phiT_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_phiT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.phiT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.phiT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.phiT
						// regulate_c_name       : lrhls_LRParameter__phiT
						// input_type_conversion : *(int*)&lrhls.LRParameter_.phiT
						if (&(lrhls.LRParameter_.phiT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__phiT_tmp_mem;
							lrhls_LRParameter__phiT_tmp_mem = *(int*)&lrhls.LRParameter_.phiT;
							lrhls_LRParameter_phiT_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__phiT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_LRParameter_phiT, "%s\n", (lrhls_LRParameter_phiT_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_phiT, tvin_lrhls_LRParameter_phiT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_phiT_depth);
		sprintf(tvin_lrhls_LRParameter_phiT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_phiT, tvin_lrhls_LRParameter_phiT);

		// release memory allocation
		delete [] lrhls_LRParameter_phiT_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_LRParameter_cotTheta, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_cotTheta, tvin_lrhls_LRParameter_cotTheta);

		sc_bv<32>* lrhls_LRParameter_cotTheta_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_cotTheta
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.cotTheta(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.cotTheta
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.cotTheta
						// regulate_c_name       : lrhls_LRParameter__cotTheta
						// input_type_conversion : *(int*)&lrhls.LRParameter_.cotTheta
						if (&(lrhls.LRParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__cotTheta_tmp_mem;
							lrhls_LRParameter__cotTheta_tmp_mem = *(int*)&lrhls.LRParameter_.cotTheta;
							lrhls_LRParameter_cotTheta_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__cotTheta_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_LRParameter_cotTheta, "%s\n", (lrhls_LRParameter_cotTheta_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_cotTheta, tvin_lrhls_LRParameter_cotTheta);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_cotTheta_depth);
		sprintf(tvin_lrhls_LRParameter_cotTheta, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_cotTheta, tvin_lrhls_LRParameter_cotTheta);

		// release memory allocation
		delete [] lrhls_LRParameter_cotTheta_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_LRParameter_zT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_zT, tvin_lrhls_LRParameter_zT);

		sc_bv<32>* lrhls_LRParameter_zT_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_zT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.zT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.zT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.zT
						// regulate_c_name       : lrhls_LRParameter__zT
						// input_type_conversion : *(int*)&lrhls.LRParameter_.zT
						if (&(lrhls.LRParameter_.zT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__zT_tmp_mem;
							lrhls_LRParameter__zT_tmp_mem = *(int*)&lrhls.LRParameter_.zT;
							lrhls_LRParameter_zT_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__zT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_LRParameter_zT, "%s\n", (lrhls_LRParameter_zT_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_zT, tvin_lrhls_LRParameter_zT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_zT_depth);
		sprintf(tvin_lrhls_LRParameter_zT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_LRParameter_zT, tvin_lrhls_LRParameter_zT);

		// release memory allocation
		delete [] lrhls_LRParameter_zT_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_size_s, tvin_lrhls_stubs_size_s);

		sc_bv<32>* lrhls_stubs_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_stubs_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.size_
						// regulate_c_name       : lrhls_stubs__size_
						// input_type_conversion : lrhls.stubs_.size_
						if (&(lrhls.stubs_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__size__tmp_mem;
							lrhls_stubs__size__tmp_mem = lrhls.stubs_.size_;
							lrhls_stubs_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_stubs_size_s, "%s\n", (lrhls_stubs_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_size_s, tvin_lrhls_stubs_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_stubs_size_s_depth);
		sprintf(tvin_lrhls_stubs_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_size_s, tvin_lrhls_stubs_size_s);

		// release memory allocation
		delete [] lrhls_stubs_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_;
							lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_;
							lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_barrel_s, tvin_lrhls_stubs_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_stubs_data_moduleHLS_barrel_s_tvin_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.barrel_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__barrel_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_stubs__data__moduleHLS__barrel__tmp_mem;
							lrhls_stubs__data__moduleHLS__barrel__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.barrel_;
							lrhls_stubs_data_moduleHLS_barrel_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubs__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_barrel_s, "%s\n", (lrhls_stubs_data_moduleHLS_barrel_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_barrel_s, tvin_lrhls_stubs_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_barrel_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_barrel_s, tvin_lrhls_stubs_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_barrel_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_psModule_s, tvin_lrhls_stubs_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_stubs_data_moduleHLS_psModule_s_tvin_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.psModule_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__psModule_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_stubs__data__moduleHLS__psModule__tmp_mem;
							lrhls_stubs__data__moduleHLS__psModule__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.psModule_;
							lrhls_stubs_data_moduleHLS_psModule_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubs__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_psModule_s, "%s\n", (lrhls_stubs_data_moduleHLS_psModule_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_psModule_s, tvin_lrhls_stubs_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_psModule_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_psModule_s, tvin_lrhls_stubs_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_psModule_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_layerId_s, tvin_lrhls_stubs_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_layerId_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.layerId_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__layerId_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__layerId__tmp_mem;
							lrhls_stubs__data__moduleHLS__layerId__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.layerId_;
							lrhls_stubs_data_moduleHLS_layerId_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_moduleHLS_layerId_s, "%s\n", (lrhls_stubs_data_moduleHLS_layerId_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_layerId_s, tvin_lrhls_stubs_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_layerId_s_depth);
		sprintf(tvin_lrhls_stubs_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_moduleHLS_layerId_s, tvin_lrhls_stubs_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_layerId_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_r_s, tvin_lrhls_stubs_data_r_s);

		sc_bv<32>* lrhls_stubs_data_r_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].r_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].r_
						// regulate_c_name       : lrhls_stubs__data__r_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].r_
						if (&(lrhls.stubs_.data_[0].r_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__r__tmp_mem;
							lrhls_stubs__data__r__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].r_;
							lrhls_stubs_data_r_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__r__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_r_s, "%s\n", (lrhls_stubs_data_r_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_r_s, tvin_lrhls_stubs_data_r_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_r_s_depth);
		sprintf(tvin_lrhls_stubs_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_r_s, tvin_lrhls_stubs_data_r_s);

		// release memory allocation
		delete [] lrhls_stubs_data_r_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_phi_s, tvin_lrhls_stubs_data_phi_s);

		sc_bv<32>* lrhls_stubs_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].phi_
						// regulate_c_name       : lrhls_stubs__data__phi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].phi_
						if (&(lrhls.stubs_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__phi__tmp_mem;
							lrhls_stubs__data__phi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].phi_;
							lrhls_stubs_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_phi_s, "%s\n", (lrhls_stubs_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_phi_s, tvin_lrhls_stubs_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_phi_s_depth);
		sprintf(tvin_lrhls_stubs_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_phi_s, tvin_lrhls_stubs_data_phi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubs_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_z_s, tvin_lrhls_stubs_data_z_s);

		sc_bv<32>* lrhls_stubs_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].z_
						// regulate_c_name       : lrhls_stubs__data__z_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].z_
						if (&(lrhls.stubs_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__z__tmp_mem;
							lrhls_stubs__data__z__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].z_;
							lrhls_stubs_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_lrhls_stubs_data_z_s, "%s\n", (lrhls_stubs_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_z_s, tvin_lrhls_stubs_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_z_s_depth);
		sprintf(tvin_lrhls_stubs_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubs_data_z_s, tvin_lrhls_stubs_data_z_s);

		// release memory allocation
		delete [] lrhls_stubs_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_valid_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_valid_s, tvin_lrhls_valid_s);

		sc_bv<1>* lrhls_valid_s_tvin_wrapc_buffer = new sc_bv<1>[1];

		// RTL Name: lrhls_valid_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.valid_(0, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.valid_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.valid_
						// regulate_c_name       : lrhls_valid_
						// input_type_conversion : lrhls.valid_
						if (&(lrhls.valid_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_valid__tmp_mem;
							lrhls_valid__tmp_mem = lrhls.valid_;
							lrhls_valid_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_valid__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_valid_s, "%s\n", (lrhls_valid_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_valid_s, tvin_lrhls_valid_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_valid_s_depth);
		sprintf(tvin_lrhls_valid_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_valid_s, tvin_lrhls_valid_s);

		// release memory allocation
		delete [] lrhls_valid_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_size_s, tvin_lrhls_stubMap_size_s);

		sc_bv<32>* lrhls_stubMap_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_stubMap_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.size_
						// regulate_c_name       : lrhls_stubMap__size_
						// input_type_conversion : lrhls.stubMap_.size_
						if (&(lrhls.stubMap_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__size__tmp_mem;
							lrhls_stubMap__size__tmp_mem = lrhls.stubMap_.size_;
							lrhls_stubMap_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_stubMap_size_s, "%s\n", (lrhls_stubMap_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_size_s, tvin_lrhls_stubMap_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_stubMap_size_s_depth);
		sprintf(tvin_lrhls_stubMap_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_size_s, tvin_lrhls_stubMap_size_s);

		// release memory allocation
		delete [] lrhls_stubMap_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_first, tvin_lrhls_stubMap_data_first);

		sc_bv<32>* lrhls_stubMap_data_first_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_stubMap_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.data_[0].first
						// regulate_c_name       : lrhls_stubMap__data__first
						// input_type_conversion : lrhls.stubMap_.data_[i_0].first
						if (&(lrhls.stubMap_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__data__first_tmp_mem;
							lrhls_stubMap__data__first_tmp_mem = lrhls.stubMap_.data_[i_0].first;
							lrhls_stubMap_data_first_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_first, "%s\n", (lrhls_stubMap_data_first_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_first, tvin_lrhls_stubMap_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_stubMap_data_first_depth);
		sprintf(tvin_lrhls_stubMap_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_first, tvin_lrhls_stubMap_data_first);

		// release memory allocation
		delete [] lrhls_stubMap_data_first_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_size_s, tvin_lrhls_stubMap_data_second_size_s);

		sc_bv<32>* lrhls_stubMap_data_second_size_s_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_stubMap_data_second_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.size_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.data_[i_0].second.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.size_
						// regulate_c_name       : lrhls_stubMap__data__second_size_
						// input_type_conversion : lrhls.stubMap_.data_[i_0].second.size_
						if (&(lrhls.stubMap_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__data__second_size__tmp_mem;
							lrhls_stubMap__data__second_size__tmp_mem = lrhls.stubMap_.data_[i_0].second.size_;
							lrhls_stubMap_data_second_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_size_s, "%s\n", (lrhls_stubMap_data_second_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_size_s, tvin_lrhls_stubMap_data_second_size_s);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_stubMap_data_second_size_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_size_s, tvin_lrhls_stubMap_data_second_size_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_;
								lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_;
								lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_;
								lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_;
								lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_;
								lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_;
								lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_;
								lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvin_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__barrel_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_;
								lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_barrel_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvin_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__psModule_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_;
								lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_psModule_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__layerId_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_;
								lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_layerId_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_r_s, tvin_lrhls_stubMap_data_second_data_r_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_r_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.r_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].r_
							// regulate_c_name       : lrhls_stubMap__data__second_data__r_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].r_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__r__tmp_mem;
								lrhls_stubMap__data__second_data__r__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_;
								lrhls_stubMap_data_second_data_r_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__r__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_r_s, "%s\n", (lrhls_stubMap_data_second_data_r_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_r_s, tvin_lrhls_stubMap_data_second_data_r_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_r_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_r_s, tvin_lrhls_stubMap_data_second_data_r_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_r_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_phi_s, tvin_lrhls_stubMap_data_second_data_phi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_phi_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.phi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].phi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__phi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].phi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__phi__tmp_mem;
								lrhls_stubMap__data__second_data__phi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_;
								lrhls_stubMap_data_second_data_phi_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__phi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_phi_s, "%s\n", (lrhls_stubMap_data_second_data_phi_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_phi_s, tvin_lrhls_stubMap_data_second_data_phi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_phi_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_phi_s, tvin_lrhls_stubMap_data_second_data_phi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_phi_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_stubMap_data_second_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_z_s, tvin_lrhls_stubMap_data_second_data_z_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_z_s_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.z_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].z_
							// regulate_c_name       : lrhls_stubMap__data__second_data__z_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].z_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__z__tmp_mem;
								lrhls_stubMap__data__second_data__z__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_;
								lrhls_stubMap_data_second_data_z_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__z__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_stubMap_data_second_data_z_s, "%s\n", (lrhls_stubMap_data_second_data_z_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_z_s, tvin_lrhls_stubMap_data_second_data_z_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_z_s_depth);
		sprintf(tvin_lrhls_stubMap_data_second_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_stubMap_data_second_data_z_s, tvin_lrhls_stubMap_data_second_data_z_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_z_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_layerPopulation_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_size_s, tvin_lrhls_layerPopulation_size_s);

		sc_bv<32>* lrhls_layerPopulation_size_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_layerPopulation_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.size_
						// regulate_c_name       : lrhls_layerPopulation__size_
						// input_type_conversion : lrhls.layerPopulation_.size_
						if (&(lrhls.layerPopulation_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__size__tmp_mem;
							lrhls_layerPopulation__size__tmp_mem = lrhls.layerPopulation_.size_;
							lrhls_layerPopulation_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_layerPopulation_size_s, "%s\n", (lrhls_layerPopulation_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_size_s, tvin_lrhls_layerPopulation_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_layerPopulation_size_s_depth);
		sprintf(tvin_lrhls_layerPopulation_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_size_s, tvin_lrhls_layerPopulation_size_s);

		// release memory allocation
		delete [] lrhls_layerPopulation_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_layerPopulation_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_first, tvin_lrhls_layerPopulation_data_first);

		sc_bv<32>* lrhls_layerPopulation_data_first_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_layerPopulation_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.data_[0].first
						// regulate_c_name       : lrhls_layerPopulation__data__first
						// input_type_conversion : lrhls.layerPopulation_.data_[i_0].first
						if (&(lrhls.layerPopulation_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__data__first_tmp_mem;
							lrhls_layerPopulation__data__first_tmp_mem = lrhls.layerPopulation_.data_[i_0].first;
							lrhls_layerPopulation_data_first_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_layerPopulation_data_first, "%s\n", (lrhls_layerPopulation_data_first_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_first, tvin_lrhls_layerPopulation_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_layerPopulation_data_first_depth);
		sprintf(tvin_lrhls_layerPopulation_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_first, tvin_lrhls_layerPopulation_data_first);

		// release memory allocation
		delete [] lrhls_layerPopulation_data_first_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_layerPopulation_data_second, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_second, tvin_lrhls_layerPopulation_data_second);

		sc_bv<32>* lrhls_layerPopulation_data_second_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_layerPopulation_data_second
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.data_.second(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.data_[i_0].second
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.data_[0].second
						// regulate_c_name       : lrhls_layerPopulation__data__second
						// input_type_conversion : lrhls.layerPopulation_.data_[i_0].second
						if (&(lrhls.layerPopulation_.data_[0].second) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__data__second_tmp_mem;
							lrhls_layerPopulation__data__second_tmp_mem = lrhls.layerPopulation_.data_[i_0].second;
							lrhls_layerPopulation_data_second_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__data__second_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_layerPopulation_data_second, "%s\n", (lrhls_layerPopulation_data_second_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_second, tvin_lrhls_layerPopulation_data_second);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_layerPopulation_data_second_depth);
		sprintf(tvin_lrhls_layerPopulation_data_second, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_layerPopulation_data_second, tvin_lrhls_layerPopulation_data_second);

		// release memory allocation
		delete [] lrhls_layerPopulation_data_second_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_first, tvin_lrhls_residuals_data_first);

		sc_bv<32>* lrhls_residuals_data_first_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_residuals_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residuals_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residuals_.data_[0].first
						// regulate_c_name       : lrhls_residuals__data__first
						// input_type_conversion : lrhls.residuals_.data_[i_0].first
						if (&(lrhls.residuals_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residuals__data__first_tmp_mem;
							lrhls_residuals__data__first_tmp_mem = lrhls.residuals_.data_[i_0].first;
							lrhls_residuals_data_first_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_residuals_data_first, "%s\n", (lrhls_residuals_data_first_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_first, tvin_lrhls_residuals_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_residuals_data_first_depth);
		sprintf(tvin_lrhls_residuals_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_first, tvin_lrhls_residuals_data_first);

		// release memory allocation
		delete [] lrhls_residuals_data_first_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_size_s, tvin_lrhls_residuals_data_second_size_s);

		sc_bv<32>* lrhls_residuals_data_second_size_s_tvin_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_residuals_data_second_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.size_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residuals_.data_[i_0].second.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.size_
						// regulate_c_name       : lrhls_residuals__data__second_size_
						// input_type_conversion : lrhls.residuals_.data_[i_0].second.size_
						if (&(lrhls.residuals_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residuals__data__second_size__tmp_mem;
							lrhls_residuals__data__second_size__tmp_mem = lrhls.residuals_.data_[i_0].second.size_;
							lrhls_residuals_data_second_size_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_size_s, "%s\n", (lrhls_residuals_data_second_size_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_size_s, tvin_lrhls_residuals_data_second_size_s);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_residuals_data_second_size_s_depth);
		sprintf(tvin_lrhls_residuals_data_second_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_size_s, tvin_lrhls_residuals_data_second_size_s);

		// release memory allocation
		delete [] lrhls_residuals_data_second_size_s_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_data_phi, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_phi, tvin_lrhls_residuals_data_second_data_phi);

		sc_bv<32>* lrhls_residuals_data_second_data_phi_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_phi
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.phi(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].phi
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].phi
							// regulate_c_name       : lrhls_residuals__data__second_data__phi
							// input_type_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi
							if (&(lrhls.residuals_.data_[0].second.data_[0].phi) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__phi_tmp_mem;
								lrhls_residuals__data__second_data__phi_tmp_mem = *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi;
								lrhls_residuals_data_second_data_phi_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__phi_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_data_phi, "%s\n", (lrhls_residuals_data_second_data_phi_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_phi, tvin_lrhls_residuals_data_second_data_phi);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_phi_depth);
		sprintf(tvin_lrhls_residuals_data_second_data_phi, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_phi, tvin_lrhls_residuals_data_second_data_phi);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_phi_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_data_z, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_z, tvin_lrhls_residuals_data_second_data_z);

		sc_bv<32>* lrhls_residuals_data_second_data_z_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_z
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.z(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].z
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].z
							// regulate_c_name       : lrhls_residuals__data__second_data__z
							// input_type_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z
							if (&(lrhls.residuals_.data_[0].second.data_[0].z) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__z_tmp_mem;
								lrhls_residuals__data__second_data__z_tmp_mem = *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z;
								lrhls_residuals_data_second_data_z_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__z_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_data_z, "%s\n", (lrhls_residuals_data_second_data_z_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_z, tvin_lrhls_residuals_data_second_data_z);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_z_depth);
		sprintf(tvin_lrhls_residuals_data_second_data_z, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_z, tvin_lrhls_residuals_data_second_data_z);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_z_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_data_layerId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_layerId, tvin_lrhls_residuals_data_second_data_layerId);

		sc_bv<32>* lrhls_residuals_data_second_data_layerId_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_layerId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.layerId(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].layerId
							// regulate_c_name       : lrhls_residuals__data__second_data__layerId
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
							if (&(lrhls.residuals_.data_[0].second.data_[0].layerId) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__layerId_tmp_mem;
								lrhls_residuals__data__second_data__layerId_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].layerId;
								lrhls_residuals_data_second_data_layerId_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__layerId_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_data_layerId, "%s\n", (lrhls_residuals_data_second_data_layerId_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_layerId, tvin_lrhls_residuals_data_second_data_layerId);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_layerId_depth);
		sprintf(tvin_lrhls_residuals_data_second_data_layerId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_layerId, tvin_lrhls_residuals_data_second_data_layerId);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_layerId_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_data_stubId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_stubId, tvin_lrhls_residuals_data_second_data_stubId);

		sc_bv<32>* lrhls_residuals_data_second_data_stubId_tvin_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_stubId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.stubId(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].stubId
							// regulate_c_name       : lrhls_residuals__data__second_data__stubId
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
							if (&(lrhls.residuals_.data_[0].second.data_[0].stubId) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__stubId_tmp_mem;
								lrhls_residuals__data__second_data__stubId_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].stubId;
								lrhls_residuals_data_second_data_stubId_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__stubId_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_data_stubId, "%s\n", (lrhls_residuals_data_second_data_stubId_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_stubId, tvin_lrhls_residuals_data_second_data_stubId);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_stubId_depth);
		sprintf(tvin_lrhls_residuals_data_second_data_stubId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_stubId, tvin_lrhls_residuals_data_second_data_stubId);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_stubId_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_residuals_data_second_data_ps, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_ps, tvin_lrhls_residuals_data_second_data_ps);

		sc_bv<1>* lrhls_residuals_data_second_data_ps_tvin_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_residuals_data_second_data_ps
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.ps(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].ps
							// regulate_c_name       : lrhls_residuals__data__second_data__ps
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
							if (&(lrhls.residuals_.data_[0].second.data_[0].ps) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_residuals__data__second_data__ps_tmp_mem;
								lrhls_residuals__data__second_data__ps_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].ps;
								lrhls_residuals_data_second_data_ps_tvin_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_residuals__data__second_data__ps_tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvin_lrhls_residuals_data_second_data_ps, "%s\n", (lrhls_residuals_data_second_data_ps_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_ps, tvin_lrhls_residuals_data_second_data_ps);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_ps_depth);
		sprintf(tvin_lrhls_residuals_data_second_data_ps, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_residuals_data_second_data_ps, tvin_lrhls_residuals_data_second_data_ps);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_ps_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lrhls_nIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lrhls_nIterations_s, tvin_lrhls_nIterations_s);

		sc_bv<32>* lrhls_nIterations_s_tvin_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_nIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.nIterations_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.nIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.nIterations_
						// regulate_c_name       : lrhls_nIterations_
						// input_type_conversion : lrhls.nIterations_
						if (&(lrhls.nIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_nIterations__tmp_mem;
							lrhls_nIterations__tmp_mem = lrhls.nIterations_;
							lrhls_nIterations_s_tvin_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_nIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_lrhls_nIterations_s, "%s\n", (lrhls_nIterations_s_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lrhls_nIterations_s, tvin_lrhls_nIterations_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_nIterations_s_depth);
		sprintf(tvin_lrhls_nIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lrhls_nIterations_s, tvin_lrhls_nIterations_s);

		// release memory allocation
		delete [] lrhls_nIterations_s_tvin_wrapc_buffer;

// [call_c_dut] ---------->

		CodeState = CALL_C_DUT;
		LR_top(lrhls);

		CodeState = DUMP_OUTPUTS;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrNumIterations_s, tvout_lrhls_track_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.settingsHLS_.lrNumIterations_;
							lrhls_track_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrNumIterations_s, tvout_lrhls_track_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrNumIterations_s, tvout_lrhls_track_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayers_s, tvout_lrhls_track_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.settingsHLS_.lrMinLayers_;
							lrhls_track_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayers_s, tvout_lrhls_track_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayers_s, tvout_lrhls_track_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.settingsHLS_.lrMinLayersPS_;
							lrhls_track_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidPhi_s, tvout_lrhls_track_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidPhi_;
							lrhls_track_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidPhi_s, tvout_lrhls_track_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidPhi_s, tvout_lrhls_track_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidZ2S_;
							lrhls_track_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZPS_s, tvout_lrhls_track_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.lrResidZPS_;
							lrhls_track_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZPS_s, tvout_lrhls_track_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_lrResidZPS_s, tvout_lrhls_track_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.chosenRofPhi_;
							lrhls_track_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofZ_s, tvout_lrhls_track_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.chosenRofZ_;
							lrhls_track_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofZ_s, tvout_lrhls_track_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_chosenRofZ_s, tvout_lrhls_track_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_invPtToDphi_s, tvout_lrhls_track_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.settingsHLS_.invPtToDphi_;
							lrhls_track_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_invPtToDphi_s, tvout_lrhls_track_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_invPtToDphi_s, tvout_lrhls_track_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.settingsHLS_.trackerNumLayers_;
							lrhls_track_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_track_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_size_s, tvout_lrhls_track_stubsHLS_size_s);

		sc_bv<32>* lrhls_track_stubsHLS_size_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_stubsHLS_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.size_
						// regulate_c_name       : lrhls_track__stubsHLS__size_
						// input_type_conversion : lrhls.track_.stubsHLS_.size_
						if (&(lrhls.track_.stubsHLS_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__size__tmp_mem;
							lrhls_track__stubsHLS__size__tmp_mem = lrhls.track_.stubsHLS_.size_;
							lrhls_track_stubsHLS_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_size_s, "%s\n", (lrhls_track_stubsHLS_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_size_s, tvout_lrhls_track_stubsHLS_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_stubsHLS_size_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_size_s, tvout_lrhls_track_stubsHLS_size_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_;
							lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvout_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__barrel_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.barrel_;
							lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_track__stubsHLS__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_barrel_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_barrel_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_barrel_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvout_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__psModule_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.psModule_;
							lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_track__stubsHLS__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_psModule_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_psModule_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_psModule_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_
						// regulate_c_name       : lrhls_track__stubsHLS__data__moduleHLS__layerId_
						// input_type_conversion : lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_
						if (&(lrhls.track_.stubsHLS_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem;
							lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem = lrhls.track_.stubsHLS_.data_[i_0].moduleHLS_.layerId_;
							lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "%s\n", (lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_moduleHLS_layerId_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_moduleHLS_layerId_s, tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_moduleHLS_layerId_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_r_s, tvout_lrhls_track_stubsHLS_data_r_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_r_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].r_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].r_
						// regulate_c_name       : lrhls_track__stubsHLS__data__r_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_
						if (&(lrhls.track_.stubsHLS_.data_[0].r_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__r__tmp_mem;
							lrhls_track__stubsHLS__data__r__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].r_;
							lrhls_track_stubsHLS_data_r_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__r__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_r_s, "%s\n", (lrhls_track_stubsHLS_data_r_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_r_s, tvout_lrhls_track_stubsHLS_data_r_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_r_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_r_s, tvout_lrhls_track_stubsHLS_data_r_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_r_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_phi_s, tvout_lrhls_track_stubsHLS_data_phi_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_phi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].phi_
						// regulate_c_name       : lrhls_track__stubsHLS__data__phi_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_
						if (&(lrhls.track_.stubsHLS_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__phi__tmp_mem;
							lrhls_track__stubsHLS__data__phi__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].phi_;
							lrhls_track_stubsHLS_data_phi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_phi_s, "%s\n", (lrhls_track_stubsHLS_data_phi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_phi_s, tvout_lrhls_track_stubsHLS_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_phi_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_phi_s, tvout_lrhls_track_stubsHLS_data_phi_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_phi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_stubsHLS_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_z_s, tvout_lrhls_track_stubsHLS_data_z_s);

		sc_bv<32>* lrhls_track_stubsHLS_data_z_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_track_stubsHLS_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.stubsHLS_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.stubsHLS_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.stubsHLS_.data_[0].z_
						// regulate_c_name       : lrhls_track__stubsHLS__data__z_
						// input_type_conversion : *(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_
						if (&(lrhls.track_.stubsHLS_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__stubsHLS__data__z__tmp_mem;
							lrhls_track__stubsHLS__data__z__tmp_mem = *(int*)&lrhls.track_.stubsHLS_.data_[i_0].z_;
							lrhls_track_stubsHLS_data_z_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__stubsHLS__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_track_stubsHLS_data_z_s, "%s\n", (lrhls_track_stubsHLS_data_z_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_z_s, tvout_lrhls_track_stubsHLS_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_track_stubsHLS_data_z_s_depth);
		sprintf(tvout_lrhls_track_stubsHLS_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_stubsHLS_data_z_s, tvout_lrhls_track_stubsHLS_data_z_s);

		// release memory allocation
		delete [] lrhls_track_stubsHLS_data_z_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_secEta_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secEta_s, tvout_lrhls_track_secEta_s);

		sc_bv<32>* lrhls_track_secEta_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_secEta_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.secEta_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.secEta_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.secEta_
						// regulate_c_name       : lrhls_track__secEta_
						// input_type_conversion : lrhls.track_.secEta_
						if (&(lrhls.track_.secEta_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__secEta__tmp_mem;
							lrhls_track__secEta__tmp_mem = lrhls.track_.secEta_;
							lrhls_track_secEta_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__secEta__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_secEta_s, "%s\n", (lrhls_track_secEta_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secEta_s, tvout_lrhls_track_secEta_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_secEta_s_depth);
		sprintf(tvout_lrhls_track_secEta_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secEta_s, tvout_lrhls_track_secEta_s);

		// release memory allocation
		delete [] lrhls_track_secEta_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_secPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secPhi_s, tvout_lrhls_track_secPhi_s);

		sc_bv<32>* lrhls_track_secPhi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_secPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.secPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.secPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.secPhi_
						// regulate_c_name       : lrhls_track__secPhi_
						// input_type_conversion : lrhls.track_.secPhi_
						if (&(lrhls.track_.secPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__secPhi__tmp_mem;
							lrhls_track__secPhi__tmp_mem = lrhls.track_.secPhi_;
							lrhls_track_secPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__secPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_secPhi_s, "%s\n", (lrhls_track_secPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secPhi_s, tvout_lrhls_track_secPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_secPhi_s_depth);
		sprintf(tvout_lrhls_track_secPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_secPhi_s, tvout_lrhls_track_secPhi_s);

		// release memory allocation
		delete [] lrhls_track_secPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_qOverPt_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_qOverPt_s, tvout_lrhls_track_qOverPt_s);

		sc_bv<32>* lrhls_track_qOverPt_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_qOverPt_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.qOverPt_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.qOverPt_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.qOverPt_
						// regulate_c_name       : lrhls_track__qOverPt_
						// input_type_conversion : *(int*)&lrhls.track_.qOverPt_
						if (&(lrhls.track_.qOverPt_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__qOverPt__tmp_mem;
							lrhls_track__qOverPt__tmp_mem = *(int*)&lrhls.track_.qOverPt_;
							lrhls_track_qOverPt_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__qOverPt__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_qOverPt_s, "%s\n", (lrhls_track_qOverPt_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_qOverPt_s, tvout_lrhls_track_qOverPt_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_qOverPt_s_depth);
		sprintf(tvout_lrhls_track_qOverPt_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_qOverPt_s, tvout_lrhls_track_qOverPt_s);

		// release memory allocation
		delete [] lrhls_track_qOverPt_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_phi_s, tvout_lrhls_track_phi_s);

		sc_bv<32>* lrhls_track_phi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.phi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.phi_
						// regulate_c_name       : lrhls_track__phi_
						// input_type_conversion : *(int*)&lrhls.track_.phi_
						if (&(lrhls.track_.phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__phi__tmp_mem;
							lrhls_track__phi__tmp_mem = *(int*)&lrhls.track_.phi_;
							lrhls_track_phi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_phi_s, "%s\n", (lrhls_track_phi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_phi_s, tvout_lrhls_track_phi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_phi_s_depth);
		sprintf(tvout_lrhls_track_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_phi_s, tvout_lrhls_track_phi_s);

		// release memory allocation
		delete [] lrhls_track_phi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_z_s, tvout_lrhls_track_z_s);

		sc_bv<32>* lrhls_track_z_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.z_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.z_
						// regulate_c_name       : lrhls_track__z_
						// input_type_conversion : *(int*)&lrhls.track_.z_
						if (&(lrhls.track_.z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__z__tmp_mem;
							lrhls_track__z__tmp_mem = *(int*)&lrhls.track_.z_;
							lrhls_track_z_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_z_s, "%s\n", (lrhls_track_z_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_z_s, tvout_lrhls_track_z_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_z_s_depth);
		sprintf(tvout_lrhls_track_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_z_s, tvout_lrhls_track_z_s);

		// release memory allocation
		delete [] lrhls_track_z_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_track_cot_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_cot_s, tvout_lrhls_track_cot_s);

		sc_bv<32>* lrhls_track_cot_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_track_cot_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.track_.cot_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.track_.cot_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.track_.cot_
						// regulate_c_name       : lrhls_track__cot_
						// input_type_conversion : *(int*)&lrhls.track_.cot_
						if (&(lrhls.track_.cot_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_track__cot__tmp_mem;
							lrhls_track__cot__tmp_mem = *(int*)&lrhls.track_.cot_;
							lrhls_track_cot_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_track__cot__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_track_cot_s, "%s\n", (lrhls_track_cot_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_track_cot_s, tvout_lrhls_track_cot_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_track_cot_s_depth);
		sprintf(tvout_lrhls_track_cot_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_track_cot_s, tvout_lrhls_track_cot_s);

		// release memory allocation
		delete [] lrhls_track_cot_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_secPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_secPhi_s, tvout_lrhls_secPhi_s);

		sc_bv<32>* lrhls_secPhi_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_secPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.secPhi_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.secPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.secPhi_
						// regulate_c_name       : lrhls_secPhi_
						// input_type_conversion : lrhls.secPhi_
						if (&(lrhls.secPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_secPhi__tmp_mem;
							lrhls_secPhi__tmp_mem = lrhls.secPhi_;
							lrhls_secPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_secPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_secPhi_s, "%s\n", (lrhls_secPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_secPhi_s, tvout_lrhls_secPhi_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_secPhi_s_depth);
		sprintf(tvout_lrhls_secPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_secPhi_s, tvout_lrhls_secPhi_s);

		// release memory allocation
		delete [] lrhls_secPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_secEta_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_secEta_s, tvout_lrhls_secEta_s);

		sc_bv<32>* lrhls_secEta_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_secEta_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.secEta_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.secEta_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.secEta_
						// regulate_c_name       : lrhls_secEta_
						// input_type_conversion : lrhls.secEta_
						if (&(lrhls.secEta_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_secEta__tmp_mem;
							lrhls_secEta__tmp_mem = lrhls.secEta_;
							lrhls_secEta_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_secEta__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_secEta_s, "%s\n", (lrhls_secEta_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_secEta_s, tvout_lrhls_secEta_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_secEta_s_depth);
		sprintf(tvout_lrhls_secEta_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_secEta_s, tvout_lrhls_secEta_s);

		// release memory allocation
		delete [] lrhls_secEta_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_HTParameter_qOverPt, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_qOverPt, tvout_lrhls_HTParameter_qOverPt);

		sc_bv<32>* lrhls_HTParameter_qOverPt_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_qOverPt
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.qOverPt(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.qOverPt
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.qOverPt
						// regulate_c_name       : lrhls_HTParameter__qOverPt
						// input_type_conversion : *(int*)&lrhls.HTParameter_.qOverPt
						if (&(lrhls.HTParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__qOverPt_tmp_mem;
							lrhls_HTParameter__qOverPt_tmp_mem = *(int*)&lrhls.HTParameter_.qOverPt;
							lrhls_HTParameter_qOverPt_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__qOverPt_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_HTParameter_qOverPt, "%s\n", (lrhls_HTParameter_qOverPt_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_qOverPt, tvout_lrhls_HTParameter_qOverPt);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_qOverPt_depth);
		sprintf(tvout_lrhls_HTParameter_qOverPt, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_qOverPt, tvout_lrhls_HTParameter_qOverPt);

		// release memory allocation
		delete [] lrhls_HTParameter_qOverPt_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_HTParameter_phiT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_phiT, tvout_lrhls_HTParameter_phiT);

		sc_bv<32>* lrhls_HTParameter_phiT_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_phiT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.phiT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.phiT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.phiT
						// regulate_c_name       : lrhls_HTParameter__phiT
						// input_type_conversion : *(int*)&lrhls.HTParameter_.phiT
						if (&(lrhls.HTParameter_.phiT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__phiT_tmp_mem;
							lrhls_HTParameter__phiT_tmp_mem = *(int*)&lrhls.HTParameter_.phiT;
							lrhls_HTParameter_phiT_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__phiT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_HTParameter_phiT, "%s\n", (lrhls_HTParameter_phiT_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_phiT, tvout_lrhls_HTParameter_phiT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_phiT_depth);
		sprintf(tvout_lrhls_HTParameter_phiT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_phiT, tvout_lrhls_HTParameter_phiT);

		// release memory allocation
		delete [] lrhls_HTParameter_phiT_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_HTParameter_cotTheta, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_cotTheta, tvout_lrhls_HTParameter_cotTheta);

		sc_bv<32>* lrhls_HTParameter_cotTheta_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_cotTheta
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.cotTheta(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.cotTheta
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.cotTheta
						// regulate_c_name       : lrhls_HTParameter__cotTheta
						// input_type_conversion : *(int*)&lrhls.HTParameter_.cotTheta
						if (&(lrhls.HTParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__cotTheta_tmp_mem;
							lrhls_HTParameter__cotTheta_tmp_mem = *(int*)&lrhls.HTParameter_.cotTheta;
							lrhls_HTParameter_cotTheta_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__cotTheta_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_HTParameter_cotTheta, "%s\n", (lrhls_HTParameter_cotTheta_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_cotTheta, tvout_lrhls_HTParameter_cotTheta);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_cotTheta_depth);
		sprintf(tvout_lrhls_HTParameter_cotTheta, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_cotTheta, tvout_lrhls_HTParameter_cotTheta);

		// release memory allocation
		delete [] lrhls_HTParameter_cotTheta_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_HTParameter_zT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_zT, tvout_lrhls_HTParameter_zT);

		sc_bv<32>* lrhls_HTParameter_zT_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_HTParameter_zT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.HTParameter_.zT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.HTParameter_.zT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.HTParameter_.zT
						// regulate_c_name       : lrhls_HTParameter__zT
						// input_type_conversion : *(int*)&lrhls.HTParameter_.zT
						if (&(lrhls.HTParameter_.zT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_HTParameter__zT_tmp_mem;
							lrhls_HTParameter__zT_tmp_mem = *(int*)&lrhls.HTParameter_.zT;
							lrhls_HTParameter_zT_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_HTParameter__zT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_HTParameter_zT, "%s\n", (lrhls_HTParameter_zT_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_zT, tvout_lrhls_HTParameter_zT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_HTParameter_zT_depth);
		sprintf(tvout_lrhls_HTParameter_zT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_HTParameter_zT, tvout_lrhls_HTParameter_zT);

		// release memory allocation
		delete [] lrhls_HTParameter_zT_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_LRParameter_qOverPt, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_qOverPt, tvout_lrhls_LRParameter_qOverPt);

		sc_bv<32>* lrhls_LRParameter_qOverPt_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_qOverPt
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.qOverPt(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.qOverPt
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.qOverPt
						// regulate_c_name       : lrhls_LRParameter__qOverPt
						// input_type_conversion : *(int*)&lrhls.LRParameter_.qOverPt
						if (&(lrhls.LRParameter_.qOverPt) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__qOverPt_tmp_mem;
							lrhls_LRParameter__qOverPt_tmp_mem = *(int*)&lrhls.LRParameter_.qOverPt;
							lrhls_LRParameter_qOverPt_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__qOverPt_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_LRParameter_qOverPt, "%s\n", (lrhls_LRParameter_qOverPt_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_qOverPt, tvout_lrhls_LRParameter_qOverPt);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_qOverPt_depth);
		sprintf(tvout_lrhls_LRParameter_qOverPt, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_qOverPt, tvout_lrhls_LRParameter_qOverPt);

		// release memory allocation
		delete [] lrhls_LRParameter_qOverPt_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_LRParameter_phiT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_phiT, tvout_lrhls_LRParameter_phiT);

		sc_bv<32>* lrhls_LRParameter_phiT_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_phiT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.phiT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.phiT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.phiT
						// regulate_c_name       : lrhls_LRParameter__phiT
						// input_type_conversion : *(int*)&lrhls.LRParameter_.phiT
						if (&(lrhls.LRParameter_.phiT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__phiT_tmp_mem;
							lrhls_LRParameter__phiT_tmp_mem = *(int*)&lrhls.LRParameter_.phiT;
							lrhls_LRParameter_phiT_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__phiT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_LRParameter_phiT, "%s\n", (lrhls_LRParameter_phiT_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_phiT, tvout_lrhls_LRParameter_phiT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_phiT_depth);
		sprintf(tvout_lrhls_LRParameter_phiT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_phiT, tvout_lrhls_LRParameter_phiT);

		// release memory allocation
		delete [] lrhls_LRParameter_phiT_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_LRParameter_cotTheta, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_cotTheta, tvout_lrhls_LRParameter_cotTheta);

		sc_bv<32>* lrhls_LRParameter_cotTheta_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_cotTheta
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.cotTheta(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.cotTheta
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.cotTheta
						// regulate_c_name       : lrhls_LRParameter__cotTheta
						// input_type_conversion : *(int*)&lrhls.LRParameter_.cotTheta
						if (&(lrhls.LRParameter_.cotTheta) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__cotTheta_tmp_mem;
							lrhls_LRParameter__cotTheta_tmp_mem = *(int*)&lrhls.LRParameter_.cotTheta;
							lrhls_LRParameter_cotTheta_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__cotTheta_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_LRParameter_cotTheta, "%s\n", (lrhls_LRParameter_cotTheta_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_cotTheta, tvout_lrhls_LRParameter_cotTheta);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_cotTheta_depth);
		sprintf(tvout_lrhls_LRParameter_cotTheta, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_cotTheta, tvout_lrhls_LRParameter_cotTheta);

		// release memory allocation
		delete [] lrhls_LRParameter_cotTheta_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_LRParameter_zT, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_zT, tvout_lrhls_LRParameter_zT);

		sc_bv<32>* lrhls_LRParameter_zT_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_LRParameter_zT
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.LRParameter_.zT(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.LRParameter_.zT
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.LRParameter_.zT
						// regulate_c_name       : lrhls_LRParameter__zT
						// input_type_conversion : *(int*)&lrhls.LRParameter_.zT
						if (&(lrhls.LRParameter_.zT) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_LRParameter__zT_tmp_mem;
							lrhls_LRParameter__zT_tmp_mem = *(int*)&lrhls.LRParameter_.zT;
							lrhls_LRParameter_zT_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_LRParameter__zT_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_LRParameter_zT, "%s\n", (lrhls_LRParameter_zT_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_zT, tvout_lrhls_LRParameter_zT);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_LRParameter_zT_depth);
		sprintf(tvout_lrhls_LRParameter_zT, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_LRParameter_zT, tvout_lrhls_LRParameter_zT);

		// release memory allocation
		delete [] lrhls_LRParameter_zT_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_size_s, tvout_lrhls_stubs_size_s);

		sc_bv<32>* lrhls_stubs_size_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_stubs_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.size_
						// regulate_c_name       : lrhls_stubs__size_
						// input_type_conversion : lrhls.stubs_.size_
						if (&(lrhls.stubs_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__size__tmp_mem;
							lrhls_stubs__size__tmp_mem = lrhls.stubs_.size_;
							lrhls_stubs_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_stubs_size_s, "%s\n", (lrhls_stubs_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_size_s, tvout_lrhls_stubs_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_stubs_size_s_depth);
		sprintf(tvout_lrhls_stubs_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_size_s, tvout_lrhls_stubs_size_s);

		// release memory allocation
		delete [] lrhls_stubs_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrNumIterations_;
							lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayers_;
							lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.lrMinLayersPS_;
							lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidPhi_;
							lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZ2S_;
							lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.lrResidZPS_;
							lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofPhi_;
							lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.chosenRofZ_;
							lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].settingsHLS_.invPtToDphi_;
							lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_stubs__data__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_
						if (&(lrhls.stubs_.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubs_.data_[i_0].settingsHLS_.trackerNumLayers_;
							lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrNumIterations_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayers_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrMinLayersPS_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidPhi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZ2S_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.lrResidZPS_;
							lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofPhi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.chosenRofZ_;
							lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.invPtToDphi_;
							lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
							lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.settingsHLS_.trackerNumLayers_;
							lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_barrel_s, tvout_lrhls_stubs_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_stubs_data_moduleHLS_barrel_s_tvout_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.barrel_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__barrel_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.barrel_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_stubs__data__moduleHLS__barrel__tmp_mem;
							lrhls_stubs__data__moduleHLS__barrel__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.barrel_;
							lrhls_stubs_data_moduleHLS_barrel_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubs__data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_barrel_s, "%s\n", (lrhls_stubs_data_moduleHLS_barrel_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_barrel_s, tvout_lrhls_stubs_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_barrel_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_barrel_s, tvout_lrhls_stubs_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_barrel_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_psModule_s, tvout_lrhls_stubs_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_stubs_data_moduleHLS_psModule_s_tvout_wrapc_buffer = new sc_bv<1>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.psModule_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__psModule_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.psModule_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_stubs__data__moduleHLS__psModule__tmp_mem;
							lrhls_stubs__data__moduleHLS__psModule__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.psModule_;
							lrhls_stubs_data_moduleHLS_psModule_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubs__data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_psModule_s, "%s\n", (lrhls_stubs_data_moduleHLS_psModule_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_psModule_s, tvout_lrhls_stubs_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_psModule_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_psModule_s, tvout_lrhls_stubs_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_psModule_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_layerId_s, tvout_lrhls_stubs_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_stubs_data_moduleHLS_layerId_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].moduleHLS_.layerId_
						// regulate_c_name       : lrhls_stubs__data__moduleHLS__layerId_
						// input_type_conversion : lrhls.stubs_.data_[i_0].moduleHLS_.layerId_
						if (&(lrhls.stubs_.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__moduleHLS__layerId__tmp_mem;
							lrhls_stubs__data__moduleHLS__layerId__tmp_mem = lrhls.stubs_.data_[i_0].moduleHLS_.layerId_;
							lrhls_stubs_data_moduleHLS_layerId_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_moduleHLS_layerId_s, "%s\n", (lrhls_stubs_data_moduleHLS_layerId_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_layerId_s, tvout_lrhls_stubs_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_moduleHLS_layerId_s_depth);
		sprintf(tvout_lrhls_stubs_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_moduleHLS_layerId_s, tvout_lrhls_stubs_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_stubs_data_moduleHLS_layerId_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_r_s, tvout_lrhls_stubs_data_r_s);

		sc_bv<32>* lrhls_stubs_data_r_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.r_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].r_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].r_
						// regulate_c_name       : lrhls_stubs__data__r_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].r_
						if (&(lrhls.stubs_.data_[0].r_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__r__tmp_mem;
							lrhls_stubs__data__r__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].r_;
							lrhls_stubs_data_r_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__r__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_r_s, "%s\n", (lrhls_stubs_data_r_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_r_s, tvout_lrhls_stubs_data_r_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_r_s_depth);
		sprintf(tvout_lrhls_stubs_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_r_s, tvout_lrhls_stubs_data_r_s);

		// release memory allocation
		delete [] lrhls_stubs_data_r_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_phi_s, tvout_lrhls_stubs_data_phi_s);

		sc_bv<32>* lrhls_stubs_data_phi_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.phi_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].phi_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].phi_
						// regulate_c_name       : lrhls_stubs__data__phi_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].phi_
						if (&(lrhls.stubs_.data_[0].phi_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__phi__tmp_mem;
							lrhls_stubs__data__phi__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].phi_;
							lrhls_stubs_data_phi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__phi__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_phi_s, "%s\n", (lrhls_stubs_data_phi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_phi_s, tvout_lrhls_stubs_data_phi_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_phi_s_depth);
		sprintf(tvout_lrhls_stubs_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_phi_s, tvout_lrhls_stubs_data_phi_s);

		// release memory allocation
		delete [] lrhls_stubs_data_phi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubs_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_z_s, tvout_lrhls_stubs_data_z_s);

		sc_bv<32>* lrhls_stubs_data_z_s_tvout_wrapc_buffer = new sc_bv<32>[16];

		// RTL Name: lrhls_stubs_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubs_.data_.z_(31, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubs_.data_[i_0].z_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubs_.data_[0].z_
						// regulate_c_name       : lrhls_stubs__data__z_
						// input_type_conversion : *(int*)&lrhls.stubs_.data_[i_0].z_
						if (&(lrhls.stubs_.data_[0].z_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubs__data__z__tmp_mem;
							lrhls_stubs__data__z__tmp_mem = *(int*)&lrhls.stubs_.data_[i_0].z_;
							lrhls_stubs_data_z_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubs__data__z__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvout_lrhls_stubs_data_z_s, "%s\n", (lrhls_stubs_data_z_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_z_s, tvout_lrhls_stubs_data_z_s);
		}

		tcl_file.set_num(16, &tcl_file.lrhls_stubs_data_z_s_depth);
		sprintf(tvout_lrhls_stubs_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubs_data_z_s, tvout_lrhls_stubs_data_z_s);

		// release memory allocation
		delete [] lrhls_stubs_data_z_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_valid_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_valid_s, tvout_lrhls_valid_s);

		sc_bv<1>* lrhls_valid_s_tvout_wrapc_buffer = new sc_bv<1>[1];

		// RTL Name: lrhls_valid_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.valid_(0, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.valid_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.valid_
						// regulate_c_name       : lrhls_valid_
						// input_type_conversion : lrhls.valid_
						if (&(lrhls.valid_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_valid__tmp_mem;
							lrhls_valid__tmp_mem = lrhls.valid_;
							lrhls_valid_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_valid__tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_valid_s, "%s\n", (lrhls_valid_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_valid_s, tvout_lrhls_valid_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_valid_s_depth);
		sprintf(tvout_lrhls_valid_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_valid_s, tvout_lrhls_valid_s);

		// release memory allocation
		delete [] lrhls_valid_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_size_s, tvout_lrhls_stubMap_size_s);

		sc_bv<32>* lrhls_stubMap_size_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_stubMap_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.size_
						// regulate_c_name       : lrhls_stubMap__size_
						// input_type_conversion : lrhls.stubMap_.size_
						if (&(lrhls.stubMap_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__size__tmp_mem;
							lrhls_stubMap__size__tmp_mem = lrhls.stubMap_.size_;
							lrhls_stubMap_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_stubMap_size_s, "%s\n", (lrhls_stubMap_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_size_s, tvout_lrhls_stubMap_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_stubMap_size_s_depth);
		sprintf(tvout_lrhls_stubMap_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_size_s, tvout_lrhls_stubMap_size_s);

		// release memory allocation
		delete [] lrhls_stubMap_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_first, tvout_lrhls_stubMap_data_first);

		sc_bv<32>* lrhls_stubMap_data_first_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_stubMap_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.data_[0].first
						// regulate_c_name       : lrhls_stubMap__data__first
						// input_type_conversion : lrhls.stubMap_.data_[i_0].first
						if (&(lrhls.stubMap_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__data__first_tmp_mem;
							lrhls_stubMap__data__first_tmp_mem = lrhls.stubMap_.data_[i_0].first;
							lrhls_stubMap_data_first_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_first, "%s\n", (lrhls_stubMap_data_first_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_first, tvout_lrhls_stubMap_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_stubMap_data_first_depth);
		sprintf(tvout_lrhls_stubMap_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_first, tvout_lrhls_stubMap_data_first);

		// release memory allocation
		delete [] lrhls_stubMap_data_first_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_size_s, tvout_lrhls_stubMap_data_second_size_s);

		sc_bv<32>* lrhls_stubMap_data_second_size_s_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_stubMap_data_second_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.size_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.stubMap_.data_[i_0].second.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.size_
						// regulate_c_name       : lrhls_stubMap__data__second_size_
						// input_type_conversion : lrhls.stubMap_.data_[i_0].second.size_
						if (&(lrhls.stubMap_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_stubMap__data__second_size__tmp_mem;
							lrhls_stubMap__data__second_size__tmp_mem = lrhls.stubMap_.data_[i_0].second.size_;
							lrhls_stubMap_data_second_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_size_s, "%s\n", (lrhls_stubMap_data_second_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_size_s, tvout_lrhls_stubMap_data_second_size_s);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_stubMap_data_second_size_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_size_s, tvout_lrhls_stubMap_data_second_size_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrNumIterations_;
								lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayers_;
								lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrMinLayersPS_;
								lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidPhi_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZ2S_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.lrResidZPS_;
								lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofPhi_;
								lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.chosenRofZ_;
								lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.invPtToDphi_;
								lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].settingsHLS_.trackerNumLayers_;
								lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrNumIterations_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrNumIterations_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrNumIterations_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrNumIterations__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayers_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrMinLayersPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrMinLayersPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrMinLayersPS_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrMinLayersPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidPhi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZ2S_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZ2S_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZ2S_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZ2S__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.lrResidZPS_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.lrResidZPS_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.lrResidZPS_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__lrResidZPS__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofPhi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofPhi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofPhi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofPhi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.chosenRofZ_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.chosenRofZ_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.chosenRofZ_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__chosenRofZ__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.invPtToDphi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.invPtToDphi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.invPtToDphi_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__invPtToDphi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.settingsHLS_.trackerNumLayers_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.settingsHLS_.trackerNumLayers_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.settingsHLS_.trackerNumLayers_;
								lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__settingsHLS__trackerNumLayers__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);

		sc_bv<1>* lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvout_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_barrel_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.barrel_(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__barrel_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.barrel_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.barrel_;
								lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubMap__data__second_data__moduleHLS__barrel__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_barrel_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_barrel_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_barrel_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);

		sc_bv<1>* lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvout_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_psModule_s
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.psModule_(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__psModule_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.psModule_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.psModule_;
								lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_stubMap__data__second_data__moduleHLS__psModule__tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_psModule_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_psModule_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_psModule_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_moduleHLS_layerId_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.moduleHLS_.layerId_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_
							// regulate_c_name       : lrhls_stubMap__data__second_data__moduleHLS__layerId_
							// input_type_conversion : lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].moduleHLS_.layerId_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem;
								lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem = lrhls.stubMap_.data_[i_0].second.data_[i_1].moduleHLS_.layerId_;
								lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__moduleHLS__layerId__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "%s\n", (lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_moduleHLS_layerId_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_moduleHLS_layerId_s, tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_moduleHLS_layerId_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_r_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_r_s, tvout_lrhls_stubMap_data_second_data_r_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_r_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_r_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.r_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].r_
							// regulate_c_name       : lrhls_stubMap__data__second_data__r_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].r_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__r__tmp_mem;
								lrhls_stubMap__data__second_data__r__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].r_;
								lrhls_stubMap_data_second_data_r_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__r__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_r_s, "%s\n", (lrhls_stubMap_data_second_data_r_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_r_s, tvout_lrhls_stubMap_data_second_data_r_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_r_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_r_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_r_s, tvout_lrhls_stubMap_data_second_data_r_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_r_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_phi_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_phi_s, tvout_lrhls_stubMap_data_second_data_phi_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_phi_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_phi_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.phi_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].phi_
							// regulate_c_name       : lrhls_stubMap__data__second_data__phi_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].phi_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__phi__tmp_mem;
								lrhls_stubMap__data__second_data__phi__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].phi_;
								lrhls_stubMap_data_second_data_phi_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__phi__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_phi_s, "%s\n", (lrhls_stubMap_data_second_data_phi_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_phi_s, tvout_lrhls_stubMap_data_second_data_phi_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_phi_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_phi_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_phi_s, tvout_lrhls_stubMap_data_second_data_phi_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_phi_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_stubMap_data_second_data_z_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_z_s, tvout_lrhls_stubMap_data_second_data_z_s);

		sc_bv<32>* lrhls_stubMap_data_second_data_z_s_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_stubMap_data_second_data_z_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.stubMap_.data_.second.data_.z_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.stubMap_.data_[0].second.data_[0].z_
							// regulate_c_name       : lrhls_stubMap__data__second_data__z_
							// input_type_conversion : *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_
							if (&(lrhls.stubMap_.data_[0].second.data_[0].z_) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_stubMap__data__second_data__z__tmp_mem;
								lrhls_stubMap__data__second_data__z__tmp_mem = *(int*)&lrhls.stubMap_.data_[i_0].second.data_[i_1].z_;
								lrhls_stubMap_data_second_data_z_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_stubMap__data__second_data__z__tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_stubMap_data_second_data_z_s, "%s\n", (lrhls_stubMap_data_second_data_z_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_z_s, tvout_lrhls_stubMap_data_second_data_z_s);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_stubMap_data_second_data_z_s_depth);
		sprintf(tvout_lrhls_stubMap_data_second_data_z_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_stubMap_data_second_data_z_s, tvout_lrhls_stubMap_data_second_data_z_s);

		// release memory allocation
		delete [] lrhls_stubMap_data_second_data_z_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_layerPopulation_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_size_s, tvout_lrhls_layerPopulation_size_s);

		sc_bv<32>* lrhls_layerPopulation_size_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_layerPopulation_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.size_
						// regulate_c_name       : lrhls_layerPopulation__size_
						// input_type_conversion : lrhls.layerPopulation_.size_
						if (&(lrhls.layerPopulation_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__size__tmp_mem;
							lrhls_layerPopulation__size__tmp_mem = lrhls.layerPopulation_.size_;
							lrhls_layerPopulation_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_layerPopulation_size_s, "%s\n", (lrhls_layerPopulation_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_size_s, tvout_lrhls_layerPopulation_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_layerPopulation_size_s_depth);
		sprintf(tvout_lrhls_layerPopulation_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_size_s, tvout_lrhls_layerPopulation_size_s);

		// release memory allocation
		delete [] lrhls_layerPopulation_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_layerPopulation_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_first, tvout_lrhls_layerPopulation_data_first);

		sc_bv<32>* lrhls_layerPopulation_data_first_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_layerPopulation_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.data_[0].first
						// regulate_c_name       : lrhls_layerPopulation__data__first
						// input_type_conversion : lrhls.layerPopulation_.data_[i_0].first
						if (&(lrhls.layerPopulation_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__data__first_tmp_mem;
							lrhls_layerPopulation__data__first_tmp_mem = lrhls.layerPopulation_.data_[i_0].first;
							lrhls_layerPopulation_data_first_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_layerPopulation_data_first, "%s\n", (lrhls_layerPopulation_data_first_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_first, tvout_lrhls_layerPopulation_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_layerPopulation_data_first_depth);
		sprintf(tvout_lrhls_layerPopulation_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_first, tvout_lrhls_layerPopulation_data_first);

		// release memory allocation
		delete [] lrhls_layerPopulation_data_first_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_layerPopulation_data_second, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_second, tvout_lrhls_layerPopulation_data_second);

		sc_bv<32>* lrhls_layerPopulation_data_second_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_layerPopulation_data_second
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.layerPopulation_.data_.second(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.layerPopulation_.data_[i_0].second
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.layerPopulation_.data_[0].second
						// regulate_c_name       : lrhls_layerPopulation__data__second
						// input_type_conversion : lrhls.layerPopulation_.data_[i_0].second
						if (&(lrhls.layerPopulation_.data_[0].second) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_layerPopulation__data__second_tmp_mem;
							lrhls_layerPopulation__data__second_tmp_mem = lrhls.layerPopulation_.data_[i_0].second;
							lrhls_layerPopulation_data_second_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_layerPopulation__data__second_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_layerPopulation_data_second, "%s\n", (lrhls_layerPopulation_data_second_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_second, tvout_lrhls_layerPopulation_data_second);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_layerPopulation_data_second_depth);
		sprintf(tvout_lrhls_layerPopulation_data_second, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_layerPopulation_data_second, tvout_lrhls_layerPopulation_data_second);

		// release memory allocation
		delete [] lrhls_layerPopulation_data_second_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_size_s, tvout_lrhls_residuals_size_s);

		sc_bv<32>* lrhls_residuals_size_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_residuals_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.size_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residuals_.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residuals_.size_
						// regulate_c_name       : lrhls_residuals__size_
						// input_type_conversion : lrhls.residuals_.size_
						if (&(lrhls.residuals_.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residuals__size__tmp_mem;
							lrhls_residuals__size__tmp_mem = lrhls.residuals_.size_;
							lrhls_residuals_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_residuals_size_s, "%s\n", (lrhls_residuals_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_size_s, tvout_lrhls_residuals_size_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_residuals_size_s_depth);
		sprintf(tvout_lrhls_residuals_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_size_s, tvout_lrhls_residuals_size_s);

		// release memory allocation
		delete [] lrhls_residuals_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_first, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_first, tvout_lrhls_residuals_data_first);

		sc_bv<32>* lrhls_residuals_data_first_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_residuals_data_first
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.first(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residuals_.data_[i_0].first
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residuals_.data_[0].first
						// regulate_c_name       : lrhls_residuals__data__first
						// input_type_conversion : lrhls.residuals_.data_[i_0].first
						if (&(lrhls.residuals_.data_[0].first) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residuals__data__first_tmp_mem;
							lrhls_residuals__data__first_tmp_mem = lrhls.residuals_.data_[i_0].first;
							lrhls_residuals_data_first_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__first_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_residuals_data_first, "%s\n", (lrhls_residuals_data_first_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_first, tvout_lrhls_residuals_data_first);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_residuals_data_first_depth);
		sprintf(tvout_lrhls_residuals_data_first, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_first, tvout_lrhls_residuals_data_first);

		// release memory allocation
		delete [] lrhls_residuals_data_first_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_size_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_size_s, tvout_lrhls_residuals_data_second_size_s);

		sc_bv<32>* lrhls_residuals_data_second_size_s_tvout_wrapc_buffer = new sc_bv<32>[30];

		// RTL Name: lrhls_residuals_data_second_size_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.size_(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.residuals_.data_[i_0].second.size_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.size_
						// regulate_c_name       : lrhls_residuals__data__second_size_
						// input_type_conversion : lrhls.residuals_.data_[i_0].second.size_
						if (&(lrhls.residuals_.data_[0].second.size_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_residuals__data__second_size__tmp_mem;
							lrhls_residuals__data__second_size__tmp_mem = lrhls.residuals_.data_[i_0].second.size_;
							lrhls_residuals_data_second_size_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_size__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 30; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_size_s, "%s\n", (lrhls_residuals_data_second_size_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_size_s, tvout_lrhls_residuals_data_second_size_s);
		}

		tcl_file.set_num(30, &tcl_file.lrhls_residuals_data_second_size_s_depth);
		sprintf(tvout_lrhls_residuals_data_second_size_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_size_s, tvout_lrhls_residuals_data_second_size_s);

		// release memory allocation
		delete [] lrhls_residuals_data_second_size_s_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_data_phi, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_phi, tvout_lrhls_residuals_data_second_data_phi);

		sc_bv<32>* lrhls_residuals_data_second_data_phi_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_phi
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.phi(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].phi
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].phi
							// regulate_c_name       : lrhls_residuals__data__second_data__phi
							// input_type_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi
							if (&(lrhls.residuals_.data_[0].second.data_[0].phi) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__phi_tmp_mem;
								lrhls_residuals__data__second_data__phi_tmp_mem = *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].phi;
								lrhls_residuals_data_second_data_phi_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__phi_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_data_phi, "%s\n", (lrhls_residuals_data_second_data_phi_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_phi, tvout_lrhls_residuals_data_second_data_phi);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_phi_depth);
		sprintf(tvout_lrhls_residuals_data_second_data_phi, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_phi, tvout_lrhls_residuals_data_second_data_phi);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_phi_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_data_z, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_z, tvout_lrhls_residuals_data_second_data_z);

		sc_bv<32>* lrhls_residuals_data_second_data_z_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_z
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.z(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].z
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].z
							// regulate_c_name       : lrhls_residuals__data__second_data__z
							// input_type_conversion : *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z
							if (&(lrhls.residuals_.data_[0].second.data_[0].z) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__z_tmp_mem;
								lrhls_residuals__data__second_data__z_tmp_mem = *(int*)&lrhls.residuals_.data_[i_0].second.data_[i_1].z;
								lrhls_residuals_data_second_data_z_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__z_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_data_z, "%s\n", (lrhls_residuals_data_second_data_z_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_z, tvout_lrhls_residuals_data_second_data_z);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_z_depth);
		sprintf(tvout_lrhls_residuals_data_second_data_z, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_z, tvout_lrhls_residuals_data_second_data_z);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_z_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_data_layerId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_layerId, tvout_lrhls_residuals_data_second_data_layerId);

		sc_bv<32>* lrhls_residuals_data_second_data_layerId_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_layerId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.layerId(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].layerId
							// regulate_c_name       : lrhls_residuals__data__second_data__layerId
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].layerId
							if (&(lrhls.residuals_.data_[0].second.data_[0].layerId) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__layerId_tmp_mem;
								lrhls_residuals__data__second_data__layerId_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].layerId;
								lrhls_residuals_data_second_data_layerId_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__layerId_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_data_layerId, "%s\n", (lrhls_residuals_data_second_data_layerId_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_layerId, tvout_lrhls_residuals_data_second_data_layerId);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_layerId_depth);
		sprintf(tvout_lrhls_residuals_data_second_data_layerId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_layerId, tvout_lrhls_residuals_data_second_data_layerId);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_layerId_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_data_stubId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_stubId, tvout_lrhls_residuals_data_second_data_stubId);

		sc_bv<32>* lrhls_residuals_data_second_data_stubId_tvout_wrapc_buffer = new sc_bv<32>[480];

		// RTL Name: lrhls_residuals_data_second_data_stubId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.stubId(31, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].stubId
							// regulate_c_name       : lrhls_residuals__data__second_data__stubId
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].stubId
							if (&(lrhls.residuals_.data_[0].second.data_[0].stubId) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> lrhls_residuals__data__second_data__stubId_tmp_mem;
								lrhls_residuals__data__second_data__stubId_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].stubId;
								lrhls_residuals_data_second_data_stubId_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_residuals__data__second_data__stubId_tmp_mem.range(31, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_data_stubId, "%s\n", (lrhls_residuals_data_second_data_stubId_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_stubId, tvout_lrhls_residuals_data_second_data_stubId);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_stubId_depth);
		sprintf(tvout_lrhls_residuals_data_second_data_stubId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_stubId, tvout_lrhls_residuals_data_second_data_stubId);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_stubId_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_residuals_data_second_data_ps, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_ps, tvout_lrhls_residuals_data_second_data_ps);

		sc_bv<1>* lrhls_residuals_data_second_data_ps_tvout_wrapc_buffer = new sc_bv<1>[480];

		// RTL Name: lrhls_residuals_data_second_data_ps
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.residuals_.data_.second.data_.ps(0, 0)
				{
					// carray: (0) => (29) @ (1)
					for (int i_0 = 0; i_0 <= 29; i_0 += 1)
					{
						// carray: (0) => (15) @ (1)
						for (int i_1 = 0; i_1 <= 15; i_1 += 1)
						{
							// sub                   : i_0 i_1
							// ori_name              : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : lrhls.residuals_.data_[0].second.data_[0].ps
							// regulate_c_name       : lrhls_residuals__data__second_data__ps
							// input_type_conversion : lrhls.residuals_.data_[i_0].second.data_[i_1].ps
							if (&(lrhls.residuals_.data_[0].second.data_[0].ps) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<1> lrhls_residuals__data__second_data__ps_tmp_mem;
								lrhls_residuals__data__second_data__ps_tmp_mem = lrhls.residuals_.data_[i_0].second.data_[i_1].ps;
								lrhls_residuals_data_second_data_ps_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_residuals__data__second_data__ps_tmp_mem.range(0, 0);
                                 		       hls_map_index++;
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 480; i++)
		{
			sprintf(tvout_lrhls_residuals_data_second_data_ps, "%s\n", (lrhls_residuals_data_second_data_ps_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_ps, tvout_lrhls_residuals_data_second_data_ps);
		}

		tcl_file.set_num(480, &tcl_file.lrhls_residuals_data_second_data_ps_depth);
		sprintf(tvout_lrhls_residuals_data_second_data_ps, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_residuals_data_second_data_ps, tvout_lrhls_residuals_data_second_data_ps);

		// release memory allocation
		delete [] lrhls_residuals_data_second_data_ps_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_largestResid_phi, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_phi, tvout_lrhls_largestResid_phi);

		sc_bv<32>* lrhls_largestResid_phi_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_largestResid_phi
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.largestResid_.phi(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.largestResid_.phi
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.largestResid_.phi
						// regulate_c_name       : lrhls_largestResid__phi
						// input_type_conversion : *(int*)&lrhls.largestResid_.phi
						if (&(lrhls.largestResid_.phi) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_largestResid__phi_tmp_mem;
							lrhls_largestResid__phi_tmp_mem = *(int*)&lrhls.largestResid_.phi;
							lrhls_largestResid_phi_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_largestResid__phi_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_largestResid_phi, "%s\n", (lrhls_largestResid_phi_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_phi, tvout_lrhls_largestResid_phi);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_largestResid_phi_depth);
		sprintf(tvout_lrhls_largestResid_phi, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_phi, tvout_lrhls_largestResid_phi);

		// release memory allocation
		delete [] lrhls_largestResid_phi_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_largestResid_z, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_z, tvout_lrhls_largestResid_z);

		sc_bv<32>* lrhls_largestResid_z_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_largestResid_z
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.largestResid_.z(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.largestResid_.z
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.largestResid_.z
						// regulate_c_name       : lrhls_largestResid__z
						// input_type_conversion : *(int*)&lrhls.largestResid_.z
						if (&(lrhls.largestResid_.z) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_largestResid__z_tmp_mem;
							lrhls_largestResid__z_tmp_mem = *(int*)&lrhls.largestResid_.z;
							lrhls_largestResid_z_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_largestResid__z_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_largestResid_z, "%s\n", (lrhls_largestResid_z_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_z, tvout_lrhls_largestResid_z);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_largestResid_z_depth);
		sprintf(tvout_lrhls_largestResid_z, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_z, tvout_lrhls_largestResid_z);

		// release memory allocation
		delete [] lrhls_largestResid_z_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_largestResid_layerId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_layerId, tvout_lrhls_largestResid_layerId);

		sc_bv<32>* lrhls_largestResid_layerId_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_largestResid_layerId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.largestResid_.layerId(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.largestResid_.layerId
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.largestResid_.layerId
						// regulate_c_name       : lrhls_largestResid__layerId
						// input_type_conversion : lrhls.largestResid_.layerId
						if (&(lrhls.largestResid_.layerId) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_largestResid__layerId_tmp_mem;
							lrhls_largestResid__layerId_tmp_mem = lrhls.largestResid_.layerId;
							lrhls_largestResid_layerId_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_largestResid__layerId_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_largestResid_layerId, "%s\n", (lrhls_largestResid_layerId_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_layerId, tvout_lrhls_largestResid_layerId);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_largestResid_layerId_depth);
		sprintf(tvout_lrhls_largestResid_layerId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_layerId, tvout_lrhls_largestResid_layerId);

		// release memory allocation
		delete [] lrhls_largestResid_layerId_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_largestResid_stubId, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_stubId, tvout_lrhls_largestResid_stubId);

		sc_bv<32>* lrhls_largestResid_stubId_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_largestResid_stubId
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.largestResid_.stubId(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.largestResid_.stubId
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.largestResid_.stubId
						// regulate_c_name       : lrhls_largestResid__stubId
						// input_type_conversion : lrhls.largestResid_.stubId
						if (&(lrhls.largestResid_.stubId) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_largestResid__stubId_tmp_mem;
							lrhls_largestResid__stubId_tmp_mem = lrhls.largestResid_.stubId;
							lrhls_largestResid_stubId_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_largestResid__stubId_tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_largestResid_stubId, "%s\n", (lrhls_largestResid_stubId_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_stubId, tvout_lrhls_largestResid_stubId);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_largestResid_stubId_depth);
		sprintf(tvout_lrhls_largestResid_stubId, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_stubId, tvout_lrhls_largestResid_stubId);

		// release memory allocation
		delete [] lrhls_largestResid_stubId_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_largestResid_ps, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_ps, tvout_lrhls_largestResid_ps);

		sc_bv<1>* lrhls_largestResid_ps_tvout_wrapc_buffer = new sc_bv<1>[1];

		// RTL Name: lrhls_largestResid_ps
		{
			// bitslice(0, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.largestResid_.ps(0, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.largestResid_.ps
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.largestResid_.ps
						// regulate_c_name       : lrhls_largestResid__ps
						// input_type_conversion : lrhls.largestResid_.ps
						if (&(lrhls.largestResid_.ps) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<1> lrhls_largestResid__ps_tmp_mem;
							lrhls_largestResid__ps_tmp_mem = lrhls.largestResid_.ps;
							lrhls_largestResid_ps_tvout_wrapc_buffer[hls_map_index].range(0, 0) = lrhls_largestResid__ps_tmp_mem.range(0, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_largestResid_ps, "%s\n", (lrhls_largestResid_ps_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_ps, tvout_lrhls_largestResid_ps);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_largestResid_ps_depth);
		sprintf(tvout_lrhls_largestResid_ps, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_largestResid_ps, tvout_lrhls_largestResid_ps);

		// release memory allocation
		delete [] lrhls_largestResid_ps_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_lrhls_nIterations_s, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_lrhls_nIterations_s, tvout_lrhls_nIterations_s);

		sc_bv<32>* lrhls_nIterations_s_tvout_wrapc_buffer = new sc_bv<32>[1];

		// RTL Name: lrhls_nIterations_s
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: lrhls.nIterations_(31, 0)
				{
					// carray: (0) => (0) @ (1)
					for (int i_0 = 0; i_0 <= 0; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : lrhls.nIterations_
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : lrhls.nIterations_
						// regulate_c_name       : lrhls_nIterations_
						// input_type_conversion : lrhls.nIterations_
						if (&(lrhls.nIterations_) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> lrhls_nIterations__tmp_mem;
							lrhls_nIterations__tmp_mem = lrhls.nIterations_;
							lrhls_nIterations_s_tvout_wrapc_buffer[hls_map_index].range(31, 0) = lrhls_nIterations__tmp_mem.range(31, 0);
                                 	       hls_map_index++;
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_lrhls_nIterations_s, "%s\n", (lrhls_nIterations_s_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_lrhls_nIterations_s, tvout_lrhls_nIterations_s);
		}

		tcl_file.set_num(1, &tcl_file.lrhls_nIterations_s_depth);
		sprintf(tvout_lrhls_nIterations_s, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_lrhls_nIterations_s, tvout_lrhls_nIterations_s);

		// release memory allocation
		delete [] lrhls_nIterations_s_tvout_wrapc_buffer;

		CodeState = DELETE_CHAR_BUFFERS;
		// release memory allocation: "lrhls_settings_chosenRofPhi_s"
		delete [] tvin_lrhls_settings_chosenRofPhi_s;
		// release memory allocation: "lrhls_settings_chosenRofZ_s"
		delete [] tvin_lrhls_settings_chosenRofZ_s;
		// release memory allocation: "lrhls_settings_invPtToDphi_s"
		delete [] tvin_lrhls_settings_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_size_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_size_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_size_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_size_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_barrel_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_psModule_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_moduleHLS_layerId_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_r_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_phi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_stubsHLS_data_z_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_secEta_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_secEta_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_secPhi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_secPhi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_qOverPt_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_qOverPt_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_phi_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_phi_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_z_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_z_s;
		// release memory allocation: "lrhls_data_tracksMHTHLS_data_cot_s"
		delete [] tvin_lrhls_data_tracksMHTHLS_data_cot_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_size_s"
		delete [] tvin_lrhls_data_tracksLRHLS_size_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_size_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_size_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_barrel_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_psModule_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_moduleHLS_layerId_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_r_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_phi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_stubsHLS_data_z_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_secEta_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_secEta_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_secPhi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_secPhi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_qOverPt_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_qOverPt_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_phi_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_phi_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_z_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_z_s;
		// release memory allocation: "lrhls_data_tracksLRHLS_data_cot_s"
		delete [] tvin_lrhls_data_tracksLRHLS_data_cot_s;
		// release memory allocation: "lrhls_numLayers_s"
		delete [] tvin_lrhls_numLayers_s;
		// release memory allocation: "lrhls_minLayers_s"
		delete [] tvin_lrhls_minLayers_s;
		// release memory allocation: "lrhls_minLayersPS_s"
		delete [] tvin_lrhls_minLayersPS_s;
		// release memory allocation: "lrhls_residPhi_s"
		delete [] tvin_lrhls_residPhi_s;
		// release memory allocation: "lrhls_residZ2S_s"
		delete [] tvin_lrhls_residZ2S_s;
		// release memory allocation: "lrhls_residZPS_s"
		delete [] tvin_lrhls_residZPS_s;
		// release memory allocation: "lrhls_maxIteartions_s"
		delete [] tvin_lrhls_maxIteartions_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_track_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_track_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_track_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_track_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_track_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_track_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_track_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_track_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_track_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_track_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_track_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_track_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_track_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_track_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_track_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_track_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_track_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_track_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_track_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_track_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_track_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_track_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_track_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_track_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_track_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_track_stubsHLS_size_s"
		delete [] tvin_lrhls_track_stubsHLS_size_s;
		delete [] tvout_lrhls_track_stubsHLS_size_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_track_stubsHLS_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_barrel_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_barrel_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_barrel_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_psModule_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_psModule_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_psModule_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_moduleHLS_layerId_s"
		delete [] tvin_lrhls_track_stubsHLS_data_moduleHLS_layerId_s;
		delete [] tvout_lrhls_track_stubsHLS_data_moduleHLS_layerId_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_r_s"
		delete [] tvin_lrhls_track_stubsHLS_data_r_s;
		delete [] tvout_lrhls_track_stubsHLS_data_r_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_phi_s"
		delete [] tvin_lrhls_track_stubsHLS_data_phi_s;
		delete [] tvout_lrhls_track_stubsHLS_data_phi_s;
		// release memory allocation: "lrhls_track_stubsHLS_data_z_s"
		delete [] tvin_lrhls_track_stubsHLS_data_z_s;
		delete [] tvout_lrhls_track_stubsHLS_data_z_s;
		// release memory allocation: "lrhls_track_secEta_s"
		delete [] tvin_lrhls_track_secEta_s;
		delete [] tvout_lrhls_track_secEta_s;
		// release memory allocation: "lrhls_track_secPhi_s"
		delete [] tvin_lrhls_track_secPhi_s;
		delete [] tvout_lrhls_track_secPhi_s;
		// release memory allocation: "lrhls_track_qOverPt_s"
		delete [] tvin_lrhls_track_qOverPt_s;
		delete [] tvout_lrhls_track_qOverPt_s;
		// release memory allocation: "lrhls_track_phi_s"
		delete [] tvin_lrhls_track_phi_s;
		delete [] tvout_lrhls_track_phi_s;
		// release memory allocation: "lrhls_track_z_s"
		delete [] tvin_lrhls_track_z_s;
		delete [] tvout_lrhls_track_z_s;
		// release memory allocation: "lrhls_track_cot_s"
		delete [] tvin_lrhls_track_cot_s;
		delete [] tvout_lrhls_track_cot_s;
		// release memory allocation: "lrhls_secPhi_s"
		delete [] tvout_lrhls_secPhi_s;
		// release memory allocation: "lrhls_secEta_s"
		delete [] tvout_lrhls_secEta_s;
		// release memory allocation: "lrhls_HTParameter_qOverPt"
		delete [] tvin_lrhls_HTParameter_qOverPt;
		delete [] tvout_lrhls_HTParameter_qOverPt;
		// release memory allocation: "lrhls_HTParameter_phiT"
		delete [] tvin_lrhls_HTParameter_phiT;
		delete [] tvout_lrhls_HTParameter_phiT;
		// release memory allocation: "lrhls_HTParameter_cotTheta"
		delete [] tvin_lrhls_HTParameter_cotTheta;
		delete [] tvout_lrhls_HTParameter_cotTheta;
		// release memory allocation: "lrhls_HTParameter_zT"
		delete [] tvin_lrhls_HTParameter_zT;
		delete [] tvout_lrhls_HTParameter_zT;
		// release memory allocation: "lrhls_LRParameter_qOverPt"
		delete [] tvin_lrhls_LRParameter_qOverPt;
		delete [] tvout_lrhls_LRParameter_qOverPt;
		// release memory allocation: "lrhls_LRParameter_phiT"
		delete [] tvin_lrhls_LRParameter_phiT;
		delete [] tvout_lrhls_LRParameter_phiT;
		// release memory allocation: "lrhls_LRParameter_cotTheta"
		delete [] tvin_lrhls_LRParameter_cotTheta;
		delete [] tvout_lrhls_LRParameter_cotTheta;
		// release memory allocation: "lrhls_LRParameter_zT"
		delete [] tvin_lrhls_LRParameter_zT;
		delete [] tvout_lrhls_LRParameter_zT;
		// release memory allocation: "lrhls_stubs_size_s"
		delete [] tvin_lrhls_stubs_size_s;
		delete [] tvout_lrhls_stubs_size_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_stubs_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_stubs_data_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_stubs_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_barrel_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_barrel_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_barrel_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_psModule_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_psModule_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_psModule_s;
		// release memory allocation: "lrhls_stubs_data_moduleHLS_layerId_s"
		delete [] tvin_lrhls_stubs_data_moduleHLS_layerId_s;
		delete [] tvout_lrhls_stubs_data_moduleHLS_layerId_s;
		// release memory allocation: "lrhls_stubs_data_r_s"
		delete [] tvin_lrhls_stubs_data_r_s;
		delete [] tvout_lrhls_stubs_data_r_s;
		// release memory allocation: "lrhls_stubs_data_phi_s"
		delete [] tvin_lrhls_stubs_data_phi_s;
		delete [] tvout_lrhls_stubs_data_phi_s;
		// release memory allocation: "lrhls_stubs_data_z_s"
		delete [] tvin_lrhls_stubs_data_z_s;
		delete [] tvout_lrhls_stubs_data_z_s;
		// release memory allocation: "lrhls_valid_s"
		delete [] tvin_lrhls_valid_s;
		delete [] tvout_lrhls_valid_s;
		// release memory allocation: "lrhls_stubMap_size_s"
		delete [] tvin_lrhls_stubMap_size_s;
		delete [] tvout_lrhls_stubMap_size_s;
		// release memory allocation: "lrhls_stubMap_data_first"
		delete [] tvin_lrhls_stubMap_data_first;
		delete [] tvout_lrhls_stubMap_data_first;
		// release memory allocation: "lrhls_stubMap_data_second_size_s"
		delete [] tvin_lrhls_stubMap_data_second_size_s;
		delete [] tvout_lrhls_stubMap_data_second_size_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_stubMap_data_second_data_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrNumIterations_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayers_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrMinLayersPS_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidPhi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZ2S_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_lrResidZPS_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofPhi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_chosenRofZ_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_invPtToDphi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_settingsHLS_trackerNumLayers_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_barrel_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_barrel_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_barrel_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_psModule_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_psModule_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_psModule_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_moduleHLS_layerId_s"
		delete [] tvin_lrhls_stubMap_data_second_data_moduleHLS_layerId_s;
		delete [] tvout_lrhls_stubMap_data_second_data_moduleHLS_layerId_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_r_s"
		delete [] tvin_lrhls_stubMap_data_second_data_r_s;
		delete [] tvout_lrhls_stubMap_data_second_data_r_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_phi_s"
		delete [] tvin_lrhls_stubMap_data_second_data_phi_s;
		delete [] tvout_lrhls_stubMap_data_second_data_phi_s;
		// release memory allocation: "lrhls_stubMap_data_second_data_z_s"
		delete [] tvin_lrhls_stubMap_data_second_data_z_s;
		delete [] tvout_lrhls_stubMap_data_second_data_z_s;
		// release memory allocation: "lrhls_layerPopulation_size_s"
		delete [] tvin_lrhls_layerPopulation_size_s;
		delete [] tvout_lrhls_layerPopulation_size_s;
		// release memory allocation: "lrhls_layerPopulation_data_first"
		delete [] tvin_lrhls_layerPopulation_data_first;
		delete [] tvout_lrhls_layerPopulation_data_first;
		// release memory allocation: "lrhls_layerPopulation_data_second"
		delete [] tvin_lrhls_layerPopulation_data_second;
		delete [] tvout_lrhls_layerPopulation_data_second;
		// release memory allocation: "lrhls_residuals_size_s"
		delete [] tvout_lrhls_residuals_size_s;
		// release memory allocation: "lrhls_residuals_data_first"
		delete [] tvin_lrhls_residuals_data_first;
		delete [] tvout_lrhls_residuals_data_first;
		// release memory allocation: "lrhls_residuals_data_second_size_s"
		delete [] tvin_lrhls_residuals_data_second_size_s;
		delete [] tvout_lrhls_residuals_data_second_size_s;
		// release memory allocation: "lrhls_residuals_data_second_data_phi"
		delete [] tvin_lrhls_residuals_data_second_data_phi;
		delete [] tvout_lrhls_residuals_data_second_data_phi;
		// release memory allocation: "lrhls_residuals_data_second_data_z"
		delete [] tvin_lrhls_residuals_data_second_data_z;
		delete [] tvout_lrhls_residuals_data_second_data_z;
		// release memory allocation: "lrhls_residuals_data_second_data_layerId"
		delete [] tvin_lrhls_residuals_data_second_data_layerId;
		delete [] tvout_lrhls_residuals_data_second_data_layerId;
		// release memory allocation: "lrhls_residuals_data_second_data_stubId"
		delete [] tvin_lrhls_residuals_data_second_data_stubId;
		delete [] tvout_lrhls_residuals_data_second_data_stubId;
		// release memory allocation: "lrhls_residuals_data_second_data_ps"
		delete [] tvin_lrhls_residuals_data_second_data_ps;
		delete [] tvout_lrhls_residuals_data_second_data_ps;
		// release memory allocation: "lrhls_largestResid_phi"
		delete [] tvout_lrhls_largestResid_phi;
		// release memory allocation: "lrhls_largestResid_z"
		delete [] tvout_lrhls_largestResid_z;
		// release memory allocation: "lrhls_largestResid_layerId"
		delete [] tvout_lrhls_largestResid_layerId;
		// release memory allocation: "lrhls_largestResid_stubId"
		delete [] tvout_lrhls_largestResid_stubId;
		// release memory allocation: "lrhls_largestResid_ps"
		delete [] tvout_lrhls_largestResid_ps;
		// release memory allocation: "lrhls_nIterations_s"
		delete [] tvin_lrhls_nIterations_s;
		delete [] tvout_lrhls_nIterations_s;

		AESL_transaction++;

		tcl_file.set_num(AESL_transaction , &tcl_file.trans_num);
	}
}

